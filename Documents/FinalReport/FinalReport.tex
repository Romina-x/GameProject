\documentclass[]{final_report}
\usepackage{graphicx}
\usepackage{xcolor} 
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{forest}
\usepackage{cite}
\usepackage{float}
\usepackage{url}
\usepackage[breaklinks=true]{hyperref}
\usepackage{breakurl}
\usepackage{subcaption}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a 3D Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Final Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 5800

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 13/12/2024

\vskip3em

Signature: Romina Petrozzi

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
- Rewrite this \newline
This report details the development of a 3D platformer game created using Unity, exploring concepts in game design and software engineering. The game features a fantasy forest world where the player controls a hero tasked with rescuing animals while battling goblin enemies. The report provides an overview of game engines, design patterns for video game development, and user experience considerations. It details the development process so far, including justifications for key design decisions. Additionally, the report focusses on the application of software engineering principles, such as design patterns, testing methodologies, and adherence to a consistent code style. A timeline is also included, detailing the features achieved so far and the adjustments made to the original plan.
\end{abstract}
\newpage
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
The video game industry has grown into one of the largest sectors in the entertainment industry, with video game sales being about five times higher than global music revenues, higher than consumer book sales, and similar to movie revenues \cite{marchand2013value}. This growth has been driven by many factors, including the growth of software, improvement of internet technology, and innovation \cite{zackariasson2012video} . Video games have evolved significantly over the years, progressing from simple 2D graphics to immersive 3D experiences, and with the oncoming development of virtual reality (VR) and artificial intelligence (AI) technology, they are set to become even more immersive and engaging. Creating video games is a very complex process involving many interconnected systems such as gameplay mechanics, graphics, AI, sound, animation and gameplay design. \newline

My motivation for this project stems from my interest in the VR industry. By working on this game with Unity 3D, I will gain experience using one of the most widely used engines for VR development and practice working with 3D environments. These skills will transition well into VR development, providing a good foundation for future projects in that field. Additionally, I am aiming to improve my software engineering skills, as creating large games requires solid software engineering principles. To keep up with evolving requirements and user expectations, it is important that the code stays maintainable, efficient and scalable.\newline

The genre of game being developed is a mix between 3D platformers and action-adventure games. It is set in a fantasy forest, where the player controls an axe-wielding hero tasked with rescuing trapped animals guarded by goblin enemies. There will be a set number of levels, each with increasing difficulty that the player must traverse through. They will explore each level to find and rescue each animal, with simple platforming and obstacles. Once each animal is rescued, they will follow the player around until they take them to the goal point. Points are awarded based on the number of enemies defeated in a level, and to clear each level the player must rescue all the animals being guarded by returning them to the goal. In addition, there will be extra collectibles hidden throughout the levels which will grant the player bonus health and temporary power ups. This level design aims to cater to both ``segments of players labelled as `experiencers' versus `achievers''' \cite{zhao2022dynamic} by offering contained, linear levels which also encourage exploration. A highly successful example of this design is Super Mario 3D World, which my level designs will take some inspiration from.\newline

\color{red} For the development of this game, the Unity game engine stood out as the best choice\color{black}, which provides the necessary tools and functions for 3D environments, assets and physics required for the game. Several other game engines were compared that offer 3D capabilities, such as Unreal Engine, Unity and Godot. These engines vary in features, ease of use, and capabilities, and Unity was the best fit for the game's requirements. To ensure maintainable and scalable code for the project, common design patterns for game development were researched and incorporated, such as State Machines and Object Pools which promote extendable and reusable code. Additionally, a large focus of the project was making decisions to \color{red} create a good user experience by setting up user friendly controls, user interface, camera movement and level design. \color{black}
\section{Objectives}
The main objectives for the project include:
\begin{itemize}
    \item Player Movement System
    \begin{itemize}
	\item{Create smooth movement mechanics including walking, running and jumping with proper animation blending.}
    \end{itemize}
    \item Combat System
    \begin{itemize}
	\item{Implement a basic combat system for player-enemy interactions including damage mechanics and animations for attacks, hits and deaths.}
    \end{itemize}
    \item Full User Interface
    \begin{itemize}
	\item{Implement a menu system with level selection, and a full heads up display during levels.}
    \end{itemize}
    \item Three Enemy Types
    \begin{itemize}
	\item{Create at least three types of enemies that have some variation in attack behaviours.}
    \end{itemize}
    \item Level Completion and Scoring system
    \begin{itemize}
	\item{Create scoring system based on defeated enemies, and implement end of level mechanic.}
    \end{itemize}
    \item Three Levels
    \begin{itemize}
	\item{Design three unique level layouts, increasing in difficulty.}
    \end{itemize}
    \item Testing and Optimisation
    \begin{itemize}
	\item{Playtest the game with a few users to find and fix bugs, and optimise performance for smoother gameplay.}
    \end{itemize}
    \item Design Patterns
    \begin{itemize}
	\item{Refactor code into common design patterns where appropriate.}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
Game development is a multidisciplinary process that includes areas such as creating a game concept, designing its mechanics, and creating an engaging user interface and experience. Each of these elements are equally important to create a game that is accessible, enjoyable, and polished. \color{red}This section covers the research that was carried out for the game, discussing the different approaches explored for various aspects of development. \color{black}


\section{Game Engines}
Game engines are platforms that make it easier to create computer games. They allow you to integrate and combine into single unit individual game elements such as animations, interaction with the user, or detection of collisions between objects \cite{Barczak2019}. These engines provide reusable components, allowing developers to focus on gameplay and design rather than redeveloping fundamental systems. There are many engines available, each suited to different types of projects. Popular engines for both 3D and 2D game development include Unreal Engine, Unity and Godot, while GameMaker and Construct are popular for 2D development. \color{red}As this project is focused on 3D game development, my primary research concentrated on those engines.\color{black}
\newline
Unreal Engine focuses on providing high-quality games with outstanding graphics and realism, thanks to its powerful graphics and rendering capabilities. Its Blueprint visual scripting system is a distinctive characteristic which allows programmers to build gameplay mechanics and events without writing any code. However Unreal Engine also provides the option to use C++ for more advanced customisation \cite{eventyr_2023}. While this engine offers many benefits, it comes with a very steep learning curve, as the interface and functionalities are intricate. Another drawback is that the software is resource intensive, requiring a more demanding system configuration for both gameplay and development \cite{eventyr_2023}. 
\newline
Unity is a powerful engine that is used by both small and large development studios. Its most prominent features are its user friendly interface, cross-platform compatibility, and powerful rendering and performance. It also provides a large asset library and extensive documentation. While Unity provides great performance and graphics, it is not an ideal choice for massive open worlds or intricate graphics as its performance is limited compared to that of Unreal Engine which is more suited to this type of game \cite{medium_2024}. Additionally, while Unity has a large user community and documentation, it can present a steep learning curve for those new to game development or programming, as it primarily uses C\# for scripting.
\newline
Godot is a versatile open-source game engine that offers 3D and 2D development. It offers a lightweight, user friendly interface and provides its own scripting language, GDScript which is beginner friendly. Godot also requires less power and expense to run in comparison to Unity and Unreal Engine. Some drawbacks of this engine are having a less extensive documentation and asset library in comparison to Unity and Unreal Engine, and is less suited to games that require a large range of functionality. \cite{hatton_2024}. \newline
For this game, my requirements include good tools and support for 3D development, an interface that is relatively beginner-friendly, and access to a large asset library, as I will not be creating the 3D models from scratch. Since I have chosen a stylised visual style for the game, which gives a more cartoon-like look over realism, the project does not require an engine with advanced high-end graphics capabilities. Additionally, the decision to create contained levels instead of a large open-world environment means that the engine does not need to support expansive or highly complex environments.
Unity stands out as the best fit for these requirements due to its powerful 3D development capabilities, while being less resource intensive than Unreal Engine. Additionally, it is the most vastly documented engine of the three with a large asset store making it very accessible to learn and use.


\section{Design Patterns}
As programs get larger, it is critical to write code in such a way that classes and modules can communicate with each other in an intelligent way \cite{Doran2017}. In the context of game development, the complexity of the code can become large very fast, making it important to ensure that the code is clean, reusable, and scalable. Design patterns provide solutions to common design problems, enabling code to be easily extended and reused. It is important to create reusable components to reduce the amount of code that needs to be written for the game, and additionally design patterns make code easily extendable by designing it in such a way that adding new functionality does not require many changes to the existing functionality. There are many patterns that are widely used across many types of games\color{red}, and this section will discuss the most relevant patterns to this genre of game. \color{black}


\subsection{State Machines}\label{HSM}
\color{red} State machines are a widely used design pattern in game development for managing objects that transition between predefined states. For example, a player character may switch between idle, walking, and running states based on user input. There are different variations of the state machine pattern, each addressing different levels of complexity in state transitions. These include the Finite State Machine (FSM), Concurrent State Machine (CSM), and Hierarchical State Machine (HSM). The FSM is the simplest of the three, ensuring that an object can transition between states while preventing multiple states from running simultaneously. \color{black} This pattern solves two problems: an object should change it’s behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states \cite{unity2022_patterns}. \color{red} This pattern works by defining an enum to represent a set of possible states such as walking, idle, or running, along with a state switching method that transitions between them based on specific conditions. This method determines which behavior should be executed in each state. FSMs work well for managing a simple set of states that do not overlap or interfere with one another. However, it can become complicated when additional mechanics introduce their own state dependent behaviors that overlap with the current states. For example, if a player character needs to use a weapon that has its own states: idle, attacking, or reloading, adding these into the existing FSM would double the number of states, as each movement state (idle, walking, running) would need a second version that accounts for weapon handling \cite{nystrom2011game}. \newline
This issue is addressed by the Concurrent State Machine pattern. Instead of combining movement and weapon mechanics into a single FSM, a CSM allows multiple state machines to run independently. In this case, the player character would keep references to two separate state machines, one for movement states and another for weapon states that run concurrently. This allows states from both machines to overlap while keeping each set of states independent.
The Hierarchical State Machine (HSM) builds on the FSM by introducing a hierarchy of states, enabling shared behaviors across multiple states. This is especially useful when multiple states share common functionality. For example, all movement states that keep the player grounded need to apply gravity calculations. Instead of duplicating this logic in each movement state, it can be placed in a superstate which runs alongside its substates. In this case, the superstate would handle gravity calculations for the player, while the substates manage specific movement behaviors. 
\newline
The State pattern can be used to implement state machines as opposed to using enums to represent each state. This approach defines a base state class that all individual states inherit from, encapsulating state specific behavior into dedicated classes. This makes the system more scalable for more complex and numerous states, as each state manages its own logic without relying on a large switch statement. 
\color{black} 

\subsection{Observer}\label{observer}
\color{red}
The Observer Pattern is a behavioral design pattern used to manage communication between objects in a way that allows one object (the subject) to notify multiple other objects (the observers) when its state changes. This pattern is particularly useful in games where multiple objects need to react to specific events, such as changes in the player’s health, score, or game state. In the pattern there are two main components: the subject and the observers. The subject is the object that holds the state or data, which may change over time. When an event occurs, the subject notifies all registered observers. The observers on the other hand, listen for the event changes and define the actions they need to take when notified \cite{nystrom2011game}.
\newline
An example of its use in games would be a quest system where the quest progress is the subject, and several observers such as the quest tracker, the reward system, and quest related UI elements are notified whenever the player's progress on a quest changes. When the player completes an objective within the quest, the subject (the quest class) will notify the observers (quest tracker, reward system, UI elements), which then update themselves accordingly. This ensures that all components related to the quest are synchronized without the need for the subject to directly reference each observer.
\newline
The main benefit of using the Observer Pattern in game development is that it decouples the components of the game. The subject doesn’t need to know what each observer does, only that it needs to notify them when an event occurs. This means that the subject can focus on its core functionality, while the observers can be independent. Additionally, if new observers need to be added or existing ones modified, this can be done without changing the subject class, making the system more extendable and easier to maintain.
\newline
The Observer Pattern is also helpful in event driven systems. Games are often full of events, such as when a player picks up an item, takes damage, or completes a level. Instead of having the subject manage the responses for all these events, the Observer Pattern allows different parts of the game such as the UI, sound systems, or gameplay mechanics, to listen for and respond to the relevant events. This improves the scalability of the game’s architecture as more components are added.
\color{black}

\subsection{Strategy}\label{strategy}
\color{black}The Strategy pattern is a design pattern used to define a family of behaviors and allows them to be interchangeable. \color{red} In game development, this pattern is often used to handle different behaviors that an object can perform, such as various movement styles for enemies, different attack strategies for characters, or different types of player abilities. The way this pattern works is by defining a set of behaviors in separate classes, and let the client class decide which behavior to use at runtime.
\newline
In an implementation of this pattern, the client class (like an enemy or player character) holds a reference to a strategy interface and uses it to perform a specific action, such as moving or attacking. The actual behavior is defined in separate strategy classes, each of which implements the strategy interface. This means that the client class doesn't need to know the details of the behavior, it just delegates the task to the strategy it has been assigned. This is especially useful in situations where an object may need to switch between different behaviors based on certain conditions during gameplay \cite{Doran2017}.
\newline
For example, an enemy character in a game may have different attack strategies, one for melee combat and another for ranged combat. By using the Strategy pattern, the enemy class doesn’t have to contain logic for both melee and ranged attacks. Instead, the enemy can switch between attack strategies by dynamically assigning a different strategy object, based on whether the player is close enough for a melee attack or far away for a ranged attack. This decouples the behavior logic from the enemy class, making it easier to maintain and extend. This approach also allows for more flexibility and extendability in the game's code. New behaviors can be added without modifying the existing class, and changes to existing behaviors only need to be made in the relevant strategy classes. 
\color{black}

\subsection{ObjectPool}\label{objectpool}
\color{red}
The Object Pool pattern is is used to improve performance by efficiently reusing objects that are frequently created and destroyed. It is commonly used in game development to optimise the spawning of multiple entities, such as bullets shot from a gun or groups of enemies that continuously respawn. Instead of repeatedly creating and destroying new instances of these objects, the Object Pool keeps a finite amount of pre-created objects that can be reused when needed, improving memory performance.
\newline
To implement this pattern, two main components are required which are the object pool and the pooled object. The object pool is initialised with a specified size and creates a list of pooled objects. When an object is requsted, the object pool checks for an available instance from this list and returns it for use. Once the object is no longer needed, it is returned to the pool where it is marked as available for use \cite{Doran2017}. 
\newline
A common example of this pattern in games would be a projectile system for a shooting mechanic. Instead of continuously creating and destroying projectiles, a fixed number of them are instantiated in the pool, defining the maximum number that can be active at one time. Once projectiles start firing, they are taken one by one from the pool. Once they have hit a target or disappeared, those instances are returned to the pool so that any new projectiles fired will reuse the same instances of the ones that have been disabled. 
\newline
The main way that this pattern optimises memory performance is by avoiding memory fragmentation. If instances of objects are being rapidly allocated and removed from memory, it can lead to the free space in the heap being broken into smaller pieces of memory instead of one large open block \cite{nystrom2011game}. The object pool avoids this by allocating a fixed amount of memory at the start of the game, which remains allocated until the game ends. During gameplay, objects within this pre-allocated memory are reused rather than continuously created and destroyed.
\color{black}
\subsection{Singleton}\label{singleton}
\color{red}
The Singleton pattern is a creational design pattern that ensures a class only has one instance and creates a global point of access to it. It is commonly used in games for managing systems that should only keep a single instance throughout the lifetime of the game, such as audio managers or input handlers.
Singleton instances are created using a static field within the class that stores the instance. In the constructor, if an instance already exists, the creation of a new one is prevented which ensures that only one instance is ever active at a time. Since the instance is globally accessible, any class can call it to use its methods \cite{Doran2017}. A common use case for the Singleton Pattern in games is managing game state. A game state manager tracks the current state of the game, such as whether it is running, paused, or in a menu. Since the game state must remain consistent across scenes, only one instance of the manager should exist to prevent conflicts or errors. By using a singleton, all relevant classes can access the manager globally to read and update the game state as needed. \newline
While Singletons can be convinient and easy to use, they can introduce problems in the long term. As it is essentially a global variable, which have their own drawbacks such as making it harder to track down bugs, introducing coupling between classes, and they are not concurrency friendly. Because of this, it's important to ensure Singletons are used well and in the correct context, and alternative approaches should be considered in places where they are starting to introduce such problems.
\section{Optimisation Techniques}
\color{red}
Optimisation techniques are crucial in game development, as performance lag can significantly impact the player's gameplay experience in many game genres. In particular, 3D platformers require precise movement and jumps for navigating levels and obstacles, and experiencing frame drops can make the gameplay frustrating for the player. Some of the main optimisation techniques used for games are level of detail (LOD) management, occlusion culling and frustum culling. \newline
Occlusion Culling ‘is the mechanism by which Unity avoids rendering computations for GameObjects that are fully hidden from view by other GameObjects’ \cite{Singh2022}. This means that if an object is within the camera's view but fully blocked by another object, it will not be rendered. By doing this, performance is significantly improved as resources are not wasted on elements outside of the player's immediate view. This technique is most beneficial in 3D games with large open world environments, indoor navigation, and densely structured shooter maps, where many objects may be hidden from view at any given time.
\newline
Frustum Culling is a technique similar to Occlusion Culling, aimed at optimizing performance by preventing the rendering of game objects that are outside the camera's view (view frustum). When many active objects exist outside the player's field of vision, rendering them is unnecessary, as they are not visible. By culling these objects, the game avoids overprocessing and improves efficiency, especially for objects that are computationly expensive to render. This is done by identifying which objects are relevant to the current view by performing intersection checks against the view frustum \cite{FC2020}. \newline
Figure \ref{fig:FrustumCulling} illustrates the view frustum and the surrounding areas where different types of culling take place.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{OtherImages/ViewFrustum.png}
    \caption{Diagram representing different forms of culling. \cite{FC2020}.}
    \label{fig:FrustumCulling}
\end{figure}

LOD management is an optimization technique that dynamically adjusts the complexity of an object's geometry based on its distance from the camera. In Unity, this is done by using LOD levels, which specify amount of detail of an object’s geometry to be rendered based on the object’s distance from the camera \cite{Unity2024LOD}. When an object is far from the player, a lower-detail version with fewer polygons is rendered, whereas a higher-detail version is used when the object is closer. This approach decreases the GPU's workload, freeing up resources for closer objects. This technique is particularly useful in expansive 3D environments, such as open-world games or any game featuring a vast, open map \cite{IndieGamesDevel}. Figure \ref{fig:LOD} displays three different 3D objects, each with differnt levels of detail. LOD 0 represents the highest quality model with the most polygons, while LOD 3 is the least detailed, with the fewest polygons.
\color{black}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{OtherImages/LOD.png}
    \caption{Varying levels of detail for 3D objects. \cite{LOD}.}
    \label{fig:LOD}
\end{figure}

\section{User Experience}\label{userexperience}
Creating an engaging and intuitive user interface (UI) and user experience (UX) is important in modern game development. 
UX in games includes the player's overall interaction with the game, including controls, interface design, camera systems, feedback mechanisms, and navigation flows \cite{Kramarzewski2023}. It focuses on ensuring that the game is enjoyable, accessible, and meets player expectations. 
\subsection{Camera and Controls}
Creating intuitive and easy to use controls enhances the player experience, preventing frustration and confusion from overly complex or unfamiliar controls. Designing effective input involves adhering to the principles of ergonomics and user expectations. Ergonomics refers to creating controls that are natural for hand movement, while user expectations involve using input controls that are familiar, so players can quickly learn the controls \cite{Rogers2014}. For example, the WASD keys on a keyboard are commonly used for movement in PC games because they are familiar to most players, and they allow a natural position for the hand on the keyboard. 3D platforming games typically use controller input rather than keyboard, as it allows smoother directional movement with a joystick as opposed to using arrow keys. \color{red}Genres of games like First Person Shooters (FPS), and platformers have widely accepted control schemes, for example the spacebar on keyboard or X or A button on controllers usually makes the character jump in a platformer \cite{Rogers2014}. Figure \ref{fig:Controller} shows the most commonly used button assignments for game controller in these genres. \newline
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{OtherImages/Controller.png}
    \caption{Common controller button assignments. \cite{Rogers2014}.}
    \label{fig:Controller}
\end{figure}
\color{black}
Camera systems are used in games to determine the player's perspective of the game world. \color{red} The camera style in a game significantly influences both its design and control mapping. Therefore, choosing the right camera is crucial, as bad camera controls or perspective can frustrate players and make navigation confusing, affecting the overall user experience \cite{Rogers2014}. \color{black}
\newline
Common types of camera include first-person, third-person and top-down cameras, each providing different approaches to the gameplay design \cite{Kramarzewski2023}. First person cameras show the game through the eyes of the player character, which offers a more immersive experience. \color{red} These cameras provide easier aiming for weapons (in shooters), a closer view of weapons and world objects, and make it easier to create atmospheric scenes. However, they make it harder for players to judge jump and movement distances, and since the character is not visible, players may feel less emotionally connected to them. First person cameras are therefore \color{black} commonly used for first-person shooter games like Call of Duty where precise aiming is important.
\newline 
Third person cameras are positioned slightly above and behind the player character which provides a wider view of the area with more focus on the player character. \color{red} These cameras provide some advantages over first person cameras, such as providing a wider field of view for the player to anticipate situations, and a clearer view of the character, making movement distances easier to judge. However, they are generally less immersive than first person cameras. Third person cameras are \color{black} typically used in adventure and 3D platforming games, such as The Legend of Zelda series and Super Mario Galaxy, \color{red} where movement is more complex, and the design encourages players to form an emotional connection with the character. There are different ways of implementing third person cameras. Some remain fixed while following the player, while others allow player control to look around while still tracking the character. The choice between them depends on whether a full view of the surroundings is necessary. Some games take a hybrid approach, offering limited camera control to the player \cite{Hutchinson2009}. \color{black}
\newline
Top down cameras provide a bird's eye view of the game world, \color{red} positioned directly above the player looking down on them. There are some disadvantages that come with this view, such as not being able to get a good look at the character or the game world. \cite{Rogers2014}. Traditional top down views exist alongside a variation known as the top down/side view, which keeps the same camera angle but displays characters and entities from a side perspective. Top down cameras are typically used in a variety of game genres, including Stardew Valley, and the original Legend of Zelda.
\color{black}
\subsection{Level and UI Design}\ref{level}
-Scrap most of this \newline
Level design is an important aspect of creating a compelling user experience in video games. It involves the structure and layout of the game world, including the placement of obstacles, collectibles and enemies, to provide an engaging and challenging experience for players. A well-designed level should balance challenge and accessibility, encouraging exploration and rewarding players for their progress \cite{Kramarzewski2023}. In 3D platformers and action-adventure games, levels are often designed to cater to both "achievers" and "experiencers", players who prefer completing tasks vs players who prefer exploration \cite{zhao2022dynamic}. \color{red} This balance is achieved by designing levels with a core gameplay experience that is engaging for all players while incorporating hidden rewards and exploratory elements for experiencers. At the same time, achievers are provided with clear objectives, such as additional challenges, achievements, or opportunities to earn higher scores. 
\newline
Examples of games that take this approach are Super Mario 3D World and The Legend of Zelda: Breath of the Wild which both inspire the development of this game. Super Mario 3D World follows a linear level structure but includes hidden paths, collectibles, and optional challenges that reward players for exploring beyond the main route. Each level introduces new mechanics while maintaining a clear goal, appealing to both task focused players and those who enjoy discovering secrets.
The Legend of Zelda: Breath of the Wild takes a more open ended approach, allowing players to freely explore its vast world while subtly guiding them through with environmental cues and strategic enemy placement. Shrines and side quests serve as optional rewards that encourage exploration, while structured main quests provide a clear sense of progression.
\newline
Beyond the layout of game levels, the art style and overall aesthetic help to improve the user experience. High quality artwork can have a large impact on a game. It can draw a player into a game they might have otherwise overlooked, while making the game environment feel authentic and visually captivating. Additionally, a well designed game world can create a unique atmosphere, which, when paired with the music and mechanic makes a really immersive experience. If the design of the game is visually appealing, players are more likely to tolerate imperfections in the design \cite{Jesse2019}.
\newline
The design of the user interface (UI) is important for enhancing the user experience, as it ensures the player can easily navigate the game and receive clear visual feedback to validate their actions. The user interface in video games consists of the heads up display (HUD) and various other screens, such as game over screens, settings menus, and pause menus. The HUD refers to the visual screen overlay that communicates information to the player during gameplay. Typical elements found on the HUD in 3D platforming and action-adventure games are health bars/lives, a map, quest information, and score information \cite{Rogers2014}. The HUD should display relevant information to the player but shouldn't clutter the view of the game too much. For the layout of information on the HUD, its important to prioritize an information hierarchy to ensure that the most important information stands out and is easily accessible to players. The elements should be arranged in a logical way, with the most important information placed in prominent positions on the screen \cite{Hive}. An example of an effective HUD in a 3D platforming game is found in Super Mario Odyssey. Its clear and concise design communicates essential information without obstructing the gameplay, ensuring that the player remains immersed in the game world. This is illustrated in Figure \ref{fig:MarioHUD}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{OtherImages/MarioOdysseyHUD.jpeg}
    \caption{HUD display from Super Mario Odyssey}
    \label{fig:MarioHUD}
\end{figure}
For other UI screens, - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA finish later




%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in section \ref{HSM}.  I decided specifically to use a HSM for the player's movement as there was shared behaviour that I wanted to apply across multiple states without duplicating it into each one. For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure \ref{fig:label_State} details this architecture:
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_State}
\end{figure}
\newline The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and it's Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. I chose here to use the factory pattern for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}\label{physics}
In my game, I chose to use Unity's built in Character Controller for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics \cite{unity2024_charactercontroller}. In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In my game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why I have chosen the built-in Character Controller, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk upstairs and walk on slopes \cite{unity2024_charactercontroller_reference}. The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. I used this for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so I implemented the gravity and jump mechanics separately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, I used the following equations outlined by Kyle Pittman \cite{pittman2016_jump}:
\begin{equation}
\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
\end{equation}

\begin{equation}
\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
\end{equation}
\paragraph{}
\begin{verbatim}
private void SetupJumpVariables()
{
    float timeToApex = _maxJumpTime / 2;
    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
}
\end{verbatim}
For the gravity applied to the player while grounded, I used a smaller value of gravity to avoid unnecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

%%%%%%%%%%%%%%%%%%%%%%
%%% Enemies and Combat#
\section{Enemy Movement}\label{enemy_movement}
The enemy movement in the game is implemented dynamically based on the player's proximity. \color{red} There are two enemy types, long range and short range which both exhibit different movement behaviours. Short ranged enemies start in an idle state and begin to chase the player when they come within a specified range. Once the player moves out of this range, the enemies return back to their original starting position. Long ranged enemies that shoot the player from a distance stand still, and dynamically rotate to face and aim at the player. \color{black} To implement this behaviour with intelligent navigation I chose to use Unity's AI module, which supports AI pathfinding using NavMesh Surfaces and NavMeshAgents \cite{unity2024_AI}. 
A NavMeshAgent is assigned to each enemy, allowing them to navigate across a NavMeshSurface while avoiding obstacles in their path. These agents are configured with properties such as movement speed, acceleration, avoidance priority, and movement radius, which control their movement behaviour \cite{unity2024_NavAgent}. The NavMeshSurface is assigned to the level's entire terrain, defining the ground area that the enemies can move on. This approach allows enemies to intelligently avoid obstacles and dynamically chase the player while navigating complex environments. \newline
\subsection{Architecture}
Unlike the player movement system, I chose not to implement the State Machine design pattern for the enemy movement states. The enemy states: Idle, Chasing and Returning are relatively simple, and using a State Machine would likely overcomplicate the system for such few states. However I may consider refactor the system if more complex enemy types are introduced later in development, requiring additional states or behaviours. The current design is detailed in figure \ref{fig:label_enemyMovement}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyMovementUML.drawio}
    \caption{UML Class digram of Enemy Movement System}
    \label{fig:label_enemyMovement}
\end{figure}
The FollowRadius component detects when the player enters or exits the proximity radius. It makes use of a SphereCollider which calls OnTriggerEnter() and OnTriggerExit() when the player enters or exits the radius. It communicates this to EnemyMovement using events. 
\begin{verbatim}
private void OnTriggerEnter(Collider other) 
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if (damageable != null)
    {
        PlayerEnter?.Invoke();
    }
}
\end{verbatim}
EnemyMovement subscribes to the PlayerEnter and PlayerExit events from FollowRadius and begins manages the enemy's movement coroutines based on the event. A coroutine is a method that allows you to spread tasks across several frames. It can pause execution and return control to Unity but then continue where it left off on the following frame \cite{unity2024_Coroutines}. I chose to make use of coroutines instead of the Update() method which runs every frame. This is because the enemy movement relies on constant checks for position updates such as the player's position to follow, and using a coroutine allows this behaviour to execute over time without repeatedly checking every frame. One of the coroutines from EnemyMovement is shown below:
\begin{verbatim}
private IEnumerator FollowTarget()
{
    WaitForSeconds wait = new WaitForSeconds(_updateSpeed);
    while(enabled){
        if (Target != null)
        {
            _isMoving = _agent.velocity.magnitude > 0.1f;
            _animator.SetBool(_isMovingHash, _isMoving);
            _agent.SetDestination(Target.position); 
        }
        yield return wait;
    }
}
\end{verbatim}
\color{red} RangedEnemyMovement inherits from EnemyMovement, allowing different movement behaviour for long ranged enemies. It overrides the OnPlayerEntered and OnPlayerExit methods from EnemyMovement to start and stop an aiming coroutine when the player enters or exits the FollowRadius. This enables the Enemy class to use two different movement types interchangeably depending on the enemy type, similarly to the strategy pattern.  \color{black}
The Enemy class manages the overall behaviour and state of the enemies in the game. Concerning movement, it is responsible for configuring the properties of the NavMeshAgent (such as speed and stopping distance) but delegates the actual movement logic to the EnemyMovement \color{red} or RangedEnemyMovement classes \color{black}. This separation allows the Enemy class to keep its focus on managing overall enemy behaviours while delegating the more complex logic to other dedicated classes. For movement, it works with the EnemyMovement class, while for combat, it interacts with the AttackRadius class (Detailed in \ref{combatsystem}). 

\subsection{Configurable Enemies}
Currently in the game there are \color{red} three \color{black} enemy types, Goblin Warrior, Scout \color{red}and Archer. Warrior and Scout are both \color{black} short range and vary in attack speed, health and movement speed. \color{red} Archer is a long ranged enemy with differing attack speed, health and movement properties to Warrior and Scout. \color{black} To enable multiple enemy types I used the Strategy pattern \ref{strategy} in conjunction with Unity's ScriptableObject feature. I chose to use Strategy here to enable the Enemy class to use different behaviours interchangeably without hardcoding multiple Enemy classes for different enemy types. Unity's ScriptableObject is a data container that allows you to create customisable assets in the Unity editor \cite{unity2024_ScriptableObject}. I used this along with the Strategy pattern methodology to create separate configurable data containers for the \color{red}three \color{black} different enemy types. This design is detailed in figure \ref{fig:label_strategy}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyStrategyUML.drawio}
    \caption{UML Class diagram of Enemy Strategy Pattern.}
    \label{fig:label_strategy}
\end{figure}
The EnemyScriptableObject stores all the customizable parameters, such as health, attack speed, and movement speed. The Enemy class uses the data from the assigned ScriptableObject (GoblinWarrior, GoblinScout \color{red}or GoblinArcher\color{black}) to adjust its behaviour dynamically. This approach decouples the enemy configuration from the core enemy logic, allowing new enemy types to be added easily by creating new ScriptableObjects without modifying the Enemy class. 

\section{Combat System}\label{combatsystem}
The combat system is a core feature of the game, enabling attack and damage mechanics between the player and enemies. The design focusses on handling the damage mechanic in a consistent way across both enemies and player, while accommodating their differing attack mechanics. This was achieved by creating an IDamageable interface, which must be implemented by all game objects capable of taking damage. This design is detailed in figure  \ref{fig:label_combat}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/CombatUML.drawio.png}
    \caption{UML Class diagram of Combat System}
    \label{fig:label_combat}
\end{figure}
The IDamageable interface is the core of the system, which defines a TakeDamage() method which reduces the entity's health based on an incoming damage value. Both the Enemy and PlayerHealthAndDamage classes implement this interface, ensuring damage is applied in a consistent way for both entities. 
\newline The player's combat mechanic is controlled by the WeaponAttributes class. The weapon is equipped with a Box Collider that calls the OnTriggerEnter() method on collision. Within OnTriggerEnter(), the TakeDamage() method is called on the enemy that entered the collider. 
\begin{verbatim}
private void OnTriggerEnter(Collider other)
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if(damageable != null)
    {
        // Call takedamage method on enemy
        damageable.TakeDamage(damage);
    }
}
\end{verbatim}
The WeaponManager class manages the weapon's Box Collider, ensuring that it is only enabled during the player's attack animation. This is achieved with Unity animation events, which call the EnableWeaponCollider() method at the appropriate time during the attack animation.\newline 
The enemy's combat system differs from the player's, as it does not rely on weapon collision mechanics. Instead, the AttackRadius class manages the enemy's attack behaviour. This system uses a Sphere Collider that defines a radius in which the player can take damage. When the player is within this radius, the enemy periodically attacks by calling the player's TakeDamage() method. The  attacks are based on a set delay, allowing different enemy types to vary in attack speed. The Attack coroutine from AttackRadius is shown below:
\begin{verbatim}
protected virtual IEnumerator Attack()
{
    WaitForSeconds wait = new WaitForSeconds(_attackDelay);

    // Keep attacking as long as the player is within the radius and the enemy can attack
    while (_damageable != null)
    {
        if (GetComponentInParent<Enemy>().CanAttack)
        {
            OnAttack?.Invoke(_damageable);
            _damageable.TakeDamage(_damage);
        }
        yield return wait; // Wait before the next attack
    }

    _attackCoroutine = null;
}
\end{verbatim}
\color{red} All enemy types in the game can be stunned after being hit by the player. When stunned, enemies are unable to attack until the 'get hit' animation has ended. This is controlled by a CanAttack variable defined in the Enemy class, which is checked in the Attack coroutine to determine when the enemy can attack. RangedAttackRadius provides the attack logic for the Archer enemy, which inherits from AttackRadius. This enemy begins firing arrows periodically while aiming at the player when the player has entered the RangedAttackRadius, and stops when they've left the radius. To achieve this behaviour, the Object Pool pattern \ref{objectpool} was used to manage the creation of arrows. This pattern avoids repeatedly creating and destroying arrows, improving performance. The architecture for this is shown in \ref{fig:label_objpool} below:
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/ArrowPoolUML.drawio.png}
    \caption{UML Class diagram of Object Pool Pattern}
    \label{fig:label_objpool}
\end{figure}
The ObjectPool class manages a pool of reusable objects, which in this case would be the arrows. It keeps a list (\_availableObjectsPool) of available objects to be used, and provides methods for creating a pool of objects, getting an available object to use from that pool and returning already used objects back to the pool. PoolableObject represents an object to be used in the object pool, defining a method to ensure objects that inherit from this class are returned to the object pool once disabled. The Arrow class manages the arrow prefab that will be used in the object pool, which inherits from PoolableObject. It defines all of the arrow's properties and handles dealing damage to the player on collision. RangedAttackRadius overrides the Attack coroutine from AttackRadius to implement this new behaviour shown below:
\begin{verbatim}
protected override IEnumerator Attack()
{
    WaitForSeconds Wait = new WaitForSeconds(_attackDelay);
    yield return Wait;

    // Continue attacking while there is still a target
    while (_damageable != null)
    {
        _agent.isStopped = true;

        // Get an available arrow from the pool
        PoolableObject poolableObject = _arrowPool.GetObject();
        if (poolableObject != null)
        {
            // Set up the arrow's properties
            _arrow = poolableObject.GetComponent<Arrow>();
            _arrow.Damage = _damage;
            _arrow.transform.position = transform.TransformPoint(_arrowSpawnOffset);
            _arrow.transform.rotation = _agent.transform.rotation;

            // Apply force to the arrow in the direction that the enemy is facing
            _arrow.Rigidbody.AddForce(_agent.transform.forward * 
			_arrowPrefab.MoveSpeed, ForceMode.VelocityChange);
            InvokeOnAttack(_damageable);
        }
            
        yield return Wait;
    }

    _attackCoroutine = null;
}
\end{verbatim}
Each time the ranged enemy attacks, it gets a new available arrow from the object pool using GetObject(). Then the properties of the arrow are confgured, including the damage it does and its spawn position in relation to the enemy. The Arrow prefab uses a Rigidbody component, as discussed in section \ref{physics}, which allows it to use and react to physics. This allows for a force to be applied to the arrow, shooting it in the direction of the player at a specific speed. 
\color{black}




%%%%%%%%%%%%%%%%%%%%%%
%%% Animals and Cages
\section{Animals and Cages}
\color{red} The main gameplay mechanic of the game is rescuing animals around the map. In each level there are three animals stuck within cages that are guarded by enemies for the player to find and rescue. To rescue an animal the player has to defeat the enemies that surround the animal's cage. The amount of enemies surrounding each cage varies to increase/decrease the difficulty of the parts of each level. Once the player rescues an animal they break free from the cage and follow the player around the map. The architechture of this mechanic is detailed in figure \ref{fig:label_rescue} below. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/AnimalRescueUML.drawio.png}
    \caption{UML Class diagram of Animal Rescue Mechanic}
    \label{fig:label_rescue}
\end{figure}
The Cage class controls the logic for freeing animals once all assigned enemies have been defeated. Each cage has a list of associated Enemy objects that are assigned to each specific cage in the Unity editor. The class subscribes to the OnDefeated event of each of it's associated enemies, allowing it to be notified when one of them dies. Each time OnEnemyDefeated is triggered, the cage checks if all assigned enemies in the list have been defeated. Once this condition is met, the FreeAnimal() method is called, which handles the visual and sound effects for the cage's destruction and prompts the animal to start moving. The Animal class manages this movement behavior which includes staying idle inside the cage until freed. Once freed, the Cage script calls the Animal's StartFollowing() method which allows the Animal to follow the player. The follow movement uses the same logic that the Enemy movement uses to chase the player, discussed in section \ref{enemy_movement}. To prevent animals from getting stuck around the map far from the player, a teleportation system ensures they remain near the player. The TeleportRadius class represents a sphere collider around the player for this system. If an animal exits this radius, it calls the Animal's TeleportToPlayer() method, ensuring they stay within a reasonable distance of the player.
\color{black}


%%%%%%%%%%%%%%%%%%%%%%
%%% User Experience#
\section{User Interface}
\color{red} The design of the user interface (UI) is an important part of enhancing the overall user experience for the game, as discussed in section \ref{userexperience}. Therefore creating a full UI was a large focus of the development to achieve a complete and professional looking game that is intuitive for the player to use. The UI includes a title screen, level selection menu, settings and pause menus and a HUD (Heads Up Display) for the levels.  \newline
To set up the UI components, \color{black} I made use of Unity's built-in UI package \cite{unity2024_UI} to create multiple canvases to display various types of information to the user. 
For communication between the UI elements involving health changes and relevant game objects, the Observer pattern was used, as discussed in section \ref{observer}. \color{red} The pattern was used \color{black} in this context to decouple the UI components from the game logic. This allows the game objects to act as subjects, and notify the relevant UI components (observers) without needing to hold direct references to them. Currently, there are two subjects (the enemy and player), and three observers (the enemy and player's health bars and the game over screen). This design is shown in figure \ref{fig:label_observer1}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/HealthObserverUML.drawio.png}
    \caption{UML Class diagram of Health Observer Pattern}
    \label{fig:label_observer1}
\end{figure}
There are two interfaces to manage health changes: one for the subject and one for the observers. The IHealthSubject interface defines methods for registering, unregistering and notifying observers about health changes. The IHealthObserver interface specifies an OnNotify() method, that passes the observer the updated health value and defines what it should do given the new value. 
The PlayerHealthAndDamage and Enemy classes implement the IHealthSubject interface. Each holds a list of observers that are managed with the register and unregister observer methods. When a health change happens, the subjects notify their observers by calling the OnNotify() method for each observer in the list.  
\begin{verbatim}
public void NotifyHealthObservers()
{
    foreach (IHealthObserver observer in _observers)
    {
        observer.OnNotify(_maxHealth, _health);
    }
}
\end{verbatim}
The PlayerHealthBar, EnemyHealthBar and GameOver classes implement the IHealthObserver interface. The Game Over screen needs to observe the player's health and subsequently pop up if their health is below zero. 
The health bars observe the player and enemies to display their current health in real time. Each observer registers itself with its associated subject by calling the subject's RegisterHealthObserver(this) method. Once registered, the subject calls the observer's OnNotify() method whenever there is a health update. For example, when an Enemy notifies the EnemyHealthBar, the following method is called:
\begin{verbatim}
public void OnNotify(float maxHealth, float currentHealth)
{
    UpdateHealthBar(maxHealth, currentHealth);
}
\end{verbatim}

\color{red} 
Beyond the player and enemy health bars, additional UI elements are displayed on the HUD to communicate the player's progression through the level. At the start of a level, the HUD displays the current objective: "Rescue the animals". Then, as animals are rescued, the HUD updates dynamically to display the number rescued out of the total. Once all animals have been freed, the objective changes to "Get to the goal," and the goal is activated with a collider and visual effects to highlight its location. When the player walks into the goal collider, a level cleared screen appears, displaying the player's time and score. These events are shown in Figures \ref{fig:label_goal} and \ref{fig:label_levelcleared}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/Goal.png}
    \caption{Goal Activated}
    \label{fig:label_goal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelComplete.png}
    \caption{Level Cleared Screen}
    \label{fig:label_levelcleared}
\end{figure}

The architecture for the level progression is detailed in figure \ref{fig:label_levelprogression} below:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelProgressionUML.drawio.png}
    \caption{UML Class diagram of Level Progression}
    \label{fig:label_levelprogression}
\end{figure}

The UIQuestManager manages the quest system by tracking the number of rescued animals, updating the quest dialog, and activating the goal when all animals have been freed. The Animal class defines an OnRescued event, which UIQuestManager subscribes to in order to be notified whenever an animal is rescued. Each time UIQuestManager is notified of this event, it updates the count on the HUD and checks whether all animals have been rescued. If so, it changes the quest dialog and activates the goal. The OnAnimalRescued method, which handles this logic, is shown below:
\begin{verbatim}
private void OnAnimalRescued()
{
    _rescuedAnimals++;
    _rescuedAnimalsText.text = $"{_rescuedAnimals}/{TotalAnimalsToRescue}"; // Update UI

    // If all animals have been rescued, show new quest and activate the goal
    if (_rescuedAnimals >= _totalAnimalsToRescue && !_allAnimalsRescued)
    {
        _allAnimalsRescued = true;
        StartCoroutine(TransitionToSecondQuest());
        ActivateGoal();
    }
}
\end{verbatim}
The ActivateGoal() method enables the GoalRadius object and instantiates the visual effect that signals the goal’s activation. GoalRadius represents the collider that the player must enter to complete the level. When the player collides with it, the OnTriggerEnter() method triggers the Setup() method in the LevelCleared class, which manages the level completion screen.
LevelCleared retrieves the elapsed time from GameTimer and the total score from the ScoreManager to display them on the UI. The ScoreManager tracks the player’s score throughout the level by subscribing to the Enemy class's OnDefeat event. Each time an enemy is defeated, its score is added to the total. When LevelCleared retrieves this value, it combines it with the completion time and applies a score multiplier, rewarding players for defeating more enemies and finishing the level quickly. The Setup() method from LevelCleared, which handles this logic, is shown below:
\begin{verbatim}
public void Setup()
{
    // Activate the UI screen and change the game state
    gameObject.SetActive(true);
    LevelManager.Instance.SetGameState(LevelState.LevelCleared);

    // Play sound effect
    SoundFXManager.instance.PlaySoundFX(_levelClearedClip, transform, 1f);

    // Get the time from the game timer and convert it to minutes and seconds
    float elapsedTime = _timer.ElapsedTime;
    int minutes = Mathf.FloorToInt(elapsedTime / 60);
    int seconds = Mathf.FloorToInt(elapsedTime % 60);
    _timeText.text = $"{minutes:D2}:{seconds:D2}";

    // Get score from the score manager and add on the elapsed time
    float finalScore = (_score.Score + elapsedTime) * 10;
    _scoreText.text = $"{finalScore:N0}";
}
\end{verbatim}

Another important aspect of the UI is managing gameplay pausing during specific UI screens, such as the pause menu or game over screen, and allowing different classes to respond based on the current game state. To achieve this, the LevelManager class handles transitions between the key game states: Playing, Paused, LevelCleared, and GameOver.
This class uses the Singleton pattern, as discussed in Section \ref{singleton}, ensuring that the game state can be read globally without requiring direct references in multiple classes. Additionally, it guarantees that only one instance of LevelManager exists per level. The architecture of this system is illustrated in Figure \ref{fig:label_singletonLevelManager}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelManagerSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonLevelManager}
\end{figure}

The LevelManager implements a simple Finite State Machine (FSM) as discussed in section \ref{HSM} , managing game states using a LevelState enum to represent each level state, as each state requires minimal behavior. The SetGameState() method transitions the game to a new LevelState when called, typically triggered by UI screens associated with those states. For example, when the pause menu is activated, it calls \newline \texttt{LevelManager.Instance.SetGameState(LevelState.Paused)}, and the LevelManager handles pausing the game accordingly. Within SetGameState(), the method determines the new state and executes the appropriate logic. For instance, in the Paused state, EnableGameplay() is called to stop gameplay. Additionally, other classes can query the LevelManager to check the current game state, allowing them to execute state-specific logic only when necessary.\newline

The game also implements animated scene transitions to create a smoother and more visually appealing UI experience when navigating through menus for the user. Initially, each UI menu class contained its own button logic for loading scenes, resulting in duplicated code across multiple menu classes. The Title Screen, Level Select and each level are each a seperate scene, so most buttons, except for the pause and resume buttons within a level, take the user to a different scene. To improve maintainability and implement animated scene transitions, the button logic was refactored into a dedicated SceneLoader class. The architecture of this class is illustrated in \ref{fig:label_SceneLoader} below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{UMLDiagrams/SceneLoaderUML.drawio.png}
    \caption{UML Class diagram of SceneLoader class}
    \label{fig:label_SceneLoader}
\end{figure}

In Unity, UI buttons are components that can be attached to UI objects in a scene, each with an OnClick event that allows a method from any class to be assigned. In the game, all UI buttons reference the SceneLoader class in their OnClick events, ensuring a consistent approach to scene transitions. The SceneLoader class provides a LoadScene() method, which takes the name of the scene to load as a string, triggers the transition animation, and then loads the new scene. It also includes an ExitGame() method for buttons that allow the player to quit the game. The transition animation is handled by an object with an Animator component. When a scene loads, this object starts by covering the screen and then plays an animation to reveal the new scene. Within SceneLoader, when a button is pressed, the animator is triggered to play the 'hide' animation, and the scene transition is delayed for the duration of this animation before the new scene is loaded. This ensures smooth and visually appealing transitions between UI screens.
\color{black}

\section{User Experience}
User experience focuses on ensuring that the game is enjoyable and accessible for the player, which includes considerations for controls, camera movement, feedback mechanisms and interface design, as discussed in section \ref{userexperience}. \color{red} In the second term of the project, a user feedback form was created and sent out to gather player opinions on the game. The insights from this feedback will be discussed throughout this section.\color{black}
\subsection{Camera \& Controls}
For the camera movement, a fixed third-person perspective was implemented, \color{red} as discussed in section \ref{userexperience}.  The camera stays positioned behind the player and follows their movements without allowing the player to control its angle or view. 
This camera perspective was chosen because it is the approach used in the games that this project takes inspiration from, Super Mario 3D World and The Legend of Zelda: Link’s Awakening for Switch. Given the relatively small level sizes, full camera control is unnecessary, as the fixed perspective provides a clear view of most of the environment. Additionally, the third-person view ensures that the player can clearly see their character’s movements, which is essential for both platforming and action gameplay. \color{black}
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/PlayerCamera.png}
        \caption{FreeLook Camera on Player}
        \label{fig:label_camera}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/Zelda.png}
        \caption{Camera from Link's Awakening}
        \label{fig:label_linkcamera}
    \end{subfigure}
    \caption{Comparison of the game's camera system with Link's Awakening}
\end{figure}

To achieve smooth and dynamic camera movement for this scenario, Unity's Cinemachine package was used. Cinemachine allows you to create professional looking camera movement with automatic damping and target tracking \cite{onewheelstudio_2021}. The FreeLook camera that Cinemachine provides was used to create the third person camera as shown in figure \ref{fig:label_camera}
Cinemachine allows you to define different camera properties such as follow speed and field of view to achieve the best perspective that would show a sufficient view of the world within the camera. \newline
As discussed in \ref{userexperience}, player controls are an important factor towards offering a great user experience. To allow the player to use either keyboard inputs or game controller inputs, Unity's new Input System was used. The input system allows players to control the game in a variety of ways including external devices, touch screen or gestures \cite{unity_2024_inputsystem}. This is done by setting up 'Actions' such as running, which can have multiple input options linked to it. For example the run action is linked to both the Left Shift key on the keyboard, and the Left Trigger button on a controller. Below is an example of how the directional movement input is read using the corresponding input action:
\begin{verbatim}
private void OnMovementInput(InputAction.CallbackContext context)
{
    Vector2 input = context.ReadValue<Vector2>();
    _currentMovementInput = input;
    _isMovementPressed = input != Vector2.zero;
}
\end{verbatim}
OnMovementInput is triggered when the movement input action is performed (Joystick or WASD key movements) and provides 'context' of the action. In this case we read the input as a two dimensional vector in the direction that the player is pressing, which is then used for the Move() method of the Character Controller \ref{physics}.  \newline

\subsection{Level Design}
One of the objectives for the project surrounding user experience was to design three levels of varying difficulty. A key aspect of level design is to keep a balance between challenge and accessibility for all levels of players as discussed in \ref{userexperience}. \color{red}Since this game is aimed at all ages, it was important to start with a very easy introduction and gradually increase the difficulty. The three levels are of progressive difficulty, with the first level starting as an introduction to the game’s mechanics. Ideally, with more time, this could have been expanded into a dedicated tutorial level with full instructions on controls and core mechanics. For now, level one is designed to be linear, ensuring that players naturally encounter animals to rescue and enemies to fight without needing to search for them. The first enemies appear individually and are easy to defeat, allowing the player to learn combat mechanics in a low pressure environment. Additionally, two collectible hearts are placed in accessible locations to help players restore their health as they progress. An overview of this level is shown in figure \ref{fig:label_LevelOne}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelOne.png}
    \caption{Overview of Level One Layout}
    \label{fig:label_LevelOne}
\end{figure}

The second and third levels increase in difficulty compared to the first, with groups of two enemies guarding most cages. Unlike level one, these levels are less linear, requiring more exploration to find collectible hearts and animals to rescue. Level three presents the greatest challenge, incorporating more difficult platforming sections and additional enemies beyond those guarding cages, encouraging players to engage in combat for a higher score. This level design aimed to keep a balance between platforming and exploration while keeping the environments fairly small to maintain a short and lighthearted gameplay experience. An overview of these levels are shown in figures \ref{fig:label_LevelTwo} and \ref{fig:label_LevelThree}. \newline

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelTwo.png}
    \caption{Overview of Level Two Layout}
    \label{fig:label_LevelTwo}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelThree.png}
    \caption{Overview of Level Three Layout}
    \label{fig:label_LevelThree}
\end{figure}

In the user feedback collected during term two, players were asked whether they found the gameplay enjoyable. The results of this assessment are shown in Figure \ref{fig:label_funfeedback}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/EnjoyableFeedback.png}
    \caption{User Feedback Survey Results: Gameplay}
    \label{fig:label_funfeedback}
\end{figure}
The results ranged from neutral to strongly agree, with no users expressing disagreement, indicating that all participants found the gameplay at least somewhat enjoyable. When asked for additional feedback on this topic, two users specifically mentioned that they enjoyed the platforming elements and found the player’s movement system fun to use. Some users suggested that introducing more weapon types or attack variations could enhance the gameplay experience. Another user highlighted the game’s cute art style, stating that rescuing the animals felt rewarding. Based on this feedback, it would seem the thing most lacking from a fun gameplay experience is more variation in the combat system. Based on this feedback, the main area for improvement in the gameplay experience appears to be more variety in the combat system. Given more time, adding new attack options for the player, such as a bow and arrow, or introducing a wider range of enemy types could help to improve the overall user experience. \newline
Across all levels, each type of enemy keep the same health and damage values, determining how much damage they deal to the player and how difficult they are to defeat. Similarly, the player has fixed health and attack statistics. Balancing these values was a challenge, as it was important to ensure that enemies were neither too easy or too difficult to defeat, and similarly for the player character. These values were refined through playtesting conducted in the first term of the project, as discussed in section \ref{testing}, where feedback was gathered informally from a few users on how the difficulty could be adjusted. This continued in the second term with more formalised feedback via a user feedback form (detailed in section \ref{reflection}). The results indicated that the majority of players found the gameplay to be easy, as shown in figure \ref{fig:label_difficultyfeedback}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/DifficultyFeedback.png}
    \caption{User Feedback Survey Results: Difficulty}
    \label{fig:label_difficultyfeedback}
\end{figure}

When asked to provide additional feedback on difficulty, three users suggested increasing the enemy difficulty, either by raising their attack power or increasing their numbers in each level. Based on this feedback, the attack power of two of the weaker enemies (archer and scout) was increased to make them more challenging for the player. However, achieving a perfect balance would require further rounds of playtesting and feedback.
\color{black}
\subsection{UI Design}
\color{red}
-discuss HUD and main UI and the feedback charts \newline
In the game, there is a full UI, including a HUD, title screen, level select menu, game over screen, pause screen, settings menu, and level cleared screen, all with animated scene transitions between them. The design and layout of these elements were considered carefully and evaluated in rounds of playtesting and beta testing. First the layout and choice of elements on the HUD was an important design desicion to ensure it helps the user through the level displaying relevant information. The current design of the HUD is displayed in figure \ref{fig:label_HUD}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/HUD.png}
    \caption{Level HUD}
    \label{fig:label_HUD}
\end{figure}
The HUD elements selected for the game include health bars for both the player and enemies, an animal rescue counter, a quest tracker, and a game timer. The layout of these elements was refined through casual playtesting over the course of development, leading to several significant adjustments. Initially, the health bar had a different design and was positioned in the top left corner of the screen. However, based on user feedback, it was determined that placing the quest information in the top left was more effective, as players naturally focused their attention on the upper half of the screen.
As more HUD elements were introduced, such as the quest tracker, inconsistencies in their design made the interface appear cluttered and visually incohesive. To address this, a UI pack from the Unity Asset Store was used to standardise the design of all HUD and UI elements, ensuring they had a unified and polished look that matched the game’s overall aesthetic. The importance of maintaining visual consistency in UI design is discussed further in Section \ref{level}. Similarly, the original Level Cleared and Game Over screen were changed to use elements from this pack so that all the UI screens were cohesive. A figure showing examples of the old vs new UI screens are shown in figure \ref{oldvsnew}.
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/PlayerCamera.png}
        \caption{FreeLook Camera on Player}
        \label{fig:label_camera}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/Zelda.png}
        \caption{Camera from Link's Awakening}
        \label{fig:label_linkcamera}
    \end{subfigure}
    \caption{Comparison of the game's camera system with Link's Awakening}
\end{figure}


\color{black}

\subsection{Music and Sound Effects}
\color{red}
Music and sound effects play an important role in enhancing the player's experience and engagament with the game. They help to create an immersive atmosphere and set the mood of the game. Sound effects also serve as audio feedback for player actions, helping them better understand in game events. Since Forest Rescue is designed to be a lighthearted, casual game, the music needed to reflect this tone. The game features three music tracks: one for the title screen, another for the level select menu, and a third for gameplay. Each track is simple and cheerful, keeping the game's relaxed and happy atmosphere. For the sound effects, I incorporated a variety of sounds for key game events to provide clearer feedback to the player. These include sound effects for UI button presses, combat actions (attacking and taking damage), player movement (jumping, walking, and running), and rescuing animals. 
\newline
In the code, playing sound effects efficiently can be difficult, as they need to be triggered from various scripts without tightly coupling sound management to every individual system. To overcome this, I chose to use a singleton, as discussed in section \ref{singleton}, to create a sound effects manager class that can be accessed from anywhere in the code. This structure is detailed in figure \ref{fig:label_singletonSoundFX}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/SoundFXSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonSoundFX}
\end{figure}

The SoundFXManager class provides methods for playing both single sound effects and looping sound effects, such as the sound of running which needs to loop over time. In the Unity editor, two audio prefabs were created and assigned to the SoundFXManager via the \_soundFXObject and \_loopingSoundFXObject fields. These prefabs are used to spawn sound effects into the scene. The PlaySoundFX method takes an audio clip, a position to play it at, and a volume level. It then instantiates the \_soundFXObject prefab at the specified location, initializes it with the given audio clip and volume, and automatically destroys it once the clip has finished playing. The PlayLoopingSoundFX method functions slightly differently, as it also takes a string representing a dictionary key. To prevent multiple instances of the same sound from playing simultaneously and causing audio overlap, each looping sound effect is stored in a dictionary using the unique key. When a class needs to stop a looping sound, it calls StopLoopingSoundFX with the corresponding key. The method then checks if the key exists in the dictionary, stops and destroys the associated audio clip, and removes the entry from the dictionary to ensure proper sound management. These two methods are shown below:

\begin{verbatim}
public void StartLoopingSoundFX(string key, AudioClip audio, 
				Transform spawnPosition, float volume)
{
    // Prevent multiple instances of the same sound
    if (activeLoopingSounds.ContainsKey(key))
    {
        return; 
    }

    AudioSource audioSource = Instantiate(_loopingSoundFXObject, 
					spawnPosition.position, Quaternion.identity);
    audioSource.clip = audio;
    audioSource.volume = volume;
    audioSource.loop = true;
    audioSource.Play();

    activeLoopingSounds[key] = audioSource;
}
\end{verbatim}
\begin{verbatim}
public void StopLoopingSoundFX(string key)
{
    if (activeLoopingSounds.TryGetValue(key, out AudioSource audioSource))
    {
        audioSource.Stop();
        Destroy(audioSource.gameObject);
        activeLoopingSounds.Remove(key);
    }
}
\end{verbatim}

Since the SoundFXManager is a singleton, it ensures that only one instance exists throughout the game, preventing duplicate managers and maintaining consistent audio behavior across all scenes. This persistence avoids issues such as duplicated or overlapping sound management when transitioning between scenes. Additionally, being a singleton allows it to be easily accessed from anywhere in the code. Other classes can simply call:
\newline
\texttt{SoundFXManager.Instance.PlaySoundFX();} to concicely play sound effects where needed.

\color{black}


\section{Optimisation}
\color{red}
- Frustum Culling\newline
- LOD groups for terrain\newline
- NavMesh for pathfinding (preset data rather than realtime pathfinding)\newline
- Object pooling\newline
- Reduced physics calculations with collision matrix\newline
\color{black}
\section{Testing}\label{testing}
- Scrap most of this \newline
User testing is crucial in game development, as it provides real-world feedback on gameplay mechanics, usability and player satisfaction. This helps developers find and fix bugs, refine mechanics and enhance the user interface \cite{flashjungle_2022}. This term, I focused on conducting playtesting, a type of user testing that evaluates gameplay mechanics. Other types of user testing include usability testing and beta testing. Usability testing assesses how easily players can navigate the game and understand it's UI, and Beta testing involves testing a nearly complete version of the game in real world conditions to address bugs \cite{flashjungle_2022}. Since the game is still in development, with an incomplete user interface, I will not conduct usability or beta testing until term two. To conduct playtesting I asked different people to play the game and get feedback on what could be better about the gameplay mechanics like the player's movement and combat system. From this I received feedback that helped me better the player's jump, and refine different enemy statistics.
\color{red}
\newline - Unit Testing
\newline - Playtesting
\newline - Beta Testing
\newline - Performance Testing
\color{black}
%%%%%%%%%%%%%%%%%%%%%%
%%% Reflection and Evaluation
\chapter{Reflection and Evaluation}\label{reflection}
- Discuss how project went time wise and whether objectives were achieved
\newline - Discuss what extra i would have done given more time
\newline - Also discuss this in terms of the areas of user feedback that I didn't get time to implement
%%%%%%%%%%%%%%%%%%%%%%
%%% Professional Issues
\chapter{Professional Issues}
\color{red}
- Legal stuff with assets
\newline - Legal stuff with unity engine
\newline - More generalised legal stuff around game publishing outside of unity assets and engine

\color{red} Game development involves various professional and ethical considerations, particularly in legal compliance and asset usage when publishing a game commercially. Throughout this project, I have had to consider licensing restrictions when using third party assets and the legal requirements of publishing a game using Unity engine. This section discusses these issues and how they should be addressed professionally if this project were to be published. \newline

The majority of assets used in the game were sourced from the Unity Asset Store, which provides a large variety of assets that you can download and use in Unity Engine. Most assets from the Unity Asset Store are royalty-free on purchase or free download, except for ones labeled as 'restricted', which cannot be used commercially. Any restrictions are detailed in the description of the asset in the store \cite{UnityCommercial}. However, it is important to ensure the correct license type is purchased when downloading an asset for commercial use.
All Unity assets fall under either Extension, Single Entity, or Multi Entity licence types. Extension assets cover any assets found under the 'tools' category in the store, and users are required to purchase one seat per user that has access to the raw asset files \cite{UnityLicences}. Single Entity and Multi Entity assets can be any other type of asset that doesn't fall under the 'tools' category. Single Entity assets are typically for single users or companies, and permits use by all team members within a single company. Multi Entity assets cover parent, child and sister companies, as well as contractors on a project, allowing them access to the raw asset files across different branches of an organization \cite{UnityLicences}. Currently, all assets used in the game fall under either the Extension or Single Entity license types. As the only developer working on the game, I am a single entity, meaning these assets can be used royalty-free if the game was published commercially, and any Multi Entity licences would not need to be purchased. Failing to purchase the correct asset licenses can lead to a game being removed from distribution platforms and may result in legal disputes.

When publishing a game commercially using Unity engine, it is important to determine whether a paid Unity license is required and what tier is appropriate. Unity offers several licensing plans, with the main options being Unity Personal, Pro, Enterprise, and Industry. Unity Personal is free and intended for individual developers, while the paid tiers are designed for businesses and larger organizations.
Games can be published commercially using any of these plans, including Unity Personal. However, whether an upgrade to a paid license is required depends on 'total finances', which Unity defines based on revenue and funding. If a developer is providing services to a third party, total finances are measured by the client’s total revenue and funding, regardless of the source. If the developer is not providing services to a third party, total finances are determined by the total revenue and funding generated through the use of Unity. For governmental, non-profit, educational, or academic institutions, total finances are based on the entity’s entire budget \cite{UnityTC}.
Each licensing tier has a maximum limit on total finances for eligibility. If this limit is exceeded, the user will have to upgrade to the tier that they are elegible for to continue using Unity engine. For this project, the game was developed using Unity Personal, which allows for the game to be published commercially. However, if my total finances were to exceed the \$200,000 USD threshold, upgrading to a Unity Pro license would be required. Using the wrong Unity license would violate Unity's terms of service and could result in restrictions on both the use of the engine and the distribution of games created with it.






\color{black}

%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}
\section{Code Style}
Below is the code style I decided on, following Unity's guidelines \cite{unity_2022_codestyle}.
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Aspect}              & \textbf{Chosen Convention}                                                                                   \\ \hline
\textbf{Field Naming}        & Private fields use camelCase with a leading underscore (e.g., \texttt{\_health}, \texttt{\_animator}). Public fields use PascalCase. \\ \hline
\textbf{Property Naming}     & Public properties use PascalCase (e.g., \texttt{Health}, \texttt{MaxHealthReadOnly}).                         \\ \hline
\textbf{Interface Naming}    & Interface names start with "I" and describe behavior (e.g., \texttt{IDamageable}, \texttt{IHealthSubject}).   \\ \hline
\textbf{Event Naming}        & Events are named with verb phrases and often follow "OnEventName" format (e.g., \texttt{DoorOpened}).         \\ \hline
\textbf{Method Naming}       & Methods use  PascalCase (e.g., \texttt{TakeDamage}, \texttt{AddHealth}).                    \\ \hline
\textbf{Braces Style}        & Always include braces even for single-line conditional statements (e.g., \texttt{if (condition) \{ DoSomething(); \}}). \\ \hline
\textbf{Files per Class}     & Each class resides in its own file, and file names match MonoBehaviour class names (e.g., \texttt{PlayerHealthAndDamage.cs}). \\ \hline
\end{tabular}
\caption{Code Style Conventions Followed in the Project}
\label{tab:codestyle}
\end{table}

\section{Development Diary}
\textbf{Week 11}\newline
06/12/2024
\newline- Bugfix to player's NavMeshAgent which was causing the agent to not relocate to the player when they leave the NavMeshSurface.
\newline- Bugfix to the heart idle animation which was overriding the positions of all hearts in the scene.
\newline- Finalised level one layout
\newline04/12/2024
\newline- Refactored the UI system to use the observer pattern.
\newline03/12/2024
\newline- Added collectible hearts which increase the player's health.
\newline02/12/2024
\newline Redesigned layout and environment for level one.

\textbf{Week 10}\newline
27/11/2024
\newline- Created a second melee enemy which is faster and does less damage.
\newline25/11/2024
\newline- Created the HUD (Heads Up Display) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters its follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured its movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage

\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{OtherImages/FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name2}
\end{figure}
The Assets folder contains all of the work I have completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram highlights the most important subfolders, such as the scripts folders, where all my C\# scripts are organised. Note that not all folders are included in the diagram. \newline

Files Relevant to the Player State Machine (Assets/Fighter/Scripts):
\begin{itemize}
    \item \texttt{ PlayerBaseState.cs, PlayerRunState,cs, PlayerJumpState.cs, PlayerStateMachine.cs, PlayerStateFactory.cs} (There are other state files within this folder, Jump and Run are just two examples)
\end{itemize}

Files relevant to the combat system:
\begin{itemize}
    \item \texttt{IDamageable.cs} (Assets/Interfaces)
    \item \texttt{PlayerHealthAndDamage.cs, WeaponManager.cs, WeaponAttributes.cs} (Assets/Fighter/Scripts)
    \item \texttt{Enemy.cs, AttackRadius.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to enemy movement:
\begin{itemize}
    \item \texttt{Enemy.cs, FollowRadius.cs, EnemyMovement.cs, EnemyScriptableObject.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to the user interface:
\begin{itemize}
    \item \texttt{IHealthSubject, IHealthObserver} (Assets/Interfaces)
    \item \texttt{PlayerHealthBar.cs, EnemyHealthBar.cs, GameOver.cs} (Assets/UI/Scripts)
\end{itemize}
Files relevant to animal rescue:
\begin{itemize}
    \item \texttt{Cage.cs} (Assets/CuteRaccoons/Scripts)
    \item \texttt{IDefeatSubject.cs, IDefeatObserver.cs} (Assets/Interfaces)
\end{itemize}




\section{Demo Video Link}
\url{https://youtu.be/4mPIEk5YFJI}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\bibliographystyle{plain}
\raggedright
\bibliography{references}

\renewcommand{\bibname}{Assets Used}
\begin{thebibliography}{99}

\bibitem[25]{skybox} Key Mouse. Customizable Skybox. Available at: \url{https://assetstore.unity.com/packages/2d/textures-materials/sky/customizable-skybox-174576}

\bibitem[26]{forest_textures} Proxy Games. Stylized Nature Kit Lite. Available at: \url{https://assetstore.unity.com/packages/3d/environments/stylized-nature-kit-lite-176906}. 

\bibitem[27]{VFX} Lana Studio. Hyper Casual FX. Available at: \url{https://assetstore.unity.com/packages/vfx/particles/hyper-casual-fx-200333}.

\bibitem[28]{player} SEMA Game Studio. Modular Cute Fantasy Character Pack \#1. Available at: \url{https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/modular-cute-fantasy-character-pack-1-293865}

\bibitem[29]{sound_effects} SURIYUN. Monsters Forest Pack 2. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/monsters-forest-pack-2-251936}. 

\bibitem[30]{sound_effects} Meshtint Studio. Forest Ruins Pack Cute Series. Available at: \url{https://assetstore.unity.com/packages/3d/environments/fantasy/forest-ruins-pack-cute-series-182412}. 

\bibitem[31]{sound_effects} Lost Panda Games. Low Poly Cartoon Item Pack - 3D. Available at: \url{https://assetstore.unity.com/packages/3d/props/low-poly-cartoon-item-pack-3d-274991}. 

\bibitem[32]{sound_effects} SURIYUN. Cute Goblin. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/cute-goblin-225492}. 

\end{thebibliography}

\label{endpage}

\end{document}

\end{article}
