\documentclass[10pt]{final_report}
\usepackage{graphicx}
\usepackage{xcolor} 
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{forest}
\usepackage{cite}
\usepackage{float}
\usepackage{url}
\usepackage[breaklinks=true]{hyperref}
\usepackage{breakurl}
\usepackage{subcaption}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a 3D Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Final Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 13/12/2024

\vskip3em

Signature: Romina Petrozzi

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
This report details the development of a 3D platformer / action-adventure game built in Unity called Forest Rescue, where the player navigates a fantasy forest environment to rescue animals and defeat goblin enemies. The project explores the application of key game development principles, including design patterns, user experience design, performance optimisation, and testing methodologies. Background research was conducted to help inform technical decisions, while practical development focused on core mechanics such as combat, movement, and AI behaviour. Testing strategies such as unit testing and beta testing were used to evaluate functionality, usability, and performance. The project also reflects on professional considerations such as licensing and legal compliance for commercial publishing. 
\end{abstract}
\newpage
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
The video game industry has grown into one of the largest sectors in the entertainment industry, with video game sales being about five times higher than global music revenues, higher than consumer book sales, and similar to movie revenues \cite{marchand2013value}. This growth has been driven by many factors, including the growth of software, improvement of internet technology, and innovation \cite{zackariasson2012video} . Video games have evolved significantly over the years, progressing from simple 2D graphics to immersive 3D experiences, and with the oncoming development of virtual reality (VR) and artificial intelligence (AI) technology, they are set to become even more immersive and engaging. Creating video games is a very complex process involving many interconnected systems such as gameplay mechanics, graphics, AI, sound, animation and gameplay design. \newline

My motivation for this project stems from my interest in the VR industry. By working on this game with Unity 3D, I will gain experience using one of the most widely used engines for VR development and practice working with 3D environments. These skills will transition well into VR development, providing a good foundation for future projects in that field. Additionally, I am aiming to improve my software engineering skills, as creating large games requires solid software engineering principles. To keep up with evolving requirements and user expectations, it is important that the code stays maintainable, efficient and scalable.\newline

The genre of game developed is a mix between 3D platformers and action-adventure games. It is set in a fantasy forest, where the player controls an axe wielding hero tasked with rescuing trapped animals guarded by goblin enemies. There will be a set number of levels, each with increasing difficulty that the player must traverse through. They will explore each level to find and rescue each animal, with simple platforming and obstacles. Once each animal is rescued, they will follow the player around until they take them to the goal point. Points are awarded based on the number of enemies defeated in a level, and to clear each level the player must rescue all the animals being guarded by returning them to the goal. In addition, there will be extra collectibles hidden throughout the levels which will grant the player bonus health and temporary power ups. This level design aims to cater to both ``segments of players labelled as `experiencers' versus `achievers''' \cite{zhao2022dynamic} by offering contained, linear levels which also encourage exploration. A highly successful example of this design is Super Mario 3D World, which the level designs will take some inspiration from.\newline

For the development of this game, the Unity game engine stood out as the best choice, which provides the necessary tools and functions for 3D environments, assets and physics required for the game. Several other game engines were compared that offer 3D capabilities, such as Unreal Engine, Unity and Godot. These engines vary in features, ease of use, and capabilities, and Unity was the best fit for the game's requirements. To ensure maintainable and scalable code for the project, common design patterns for game development were researched and incorporated, such as State Machines and Object Pools which promote extendable and reusable code. Additionally, a large focus of the project was making decisions to create a good user experience by setting up user friendly controls, user interface, camera movement and level design. 

\section{Objectives}\label{objectives}
The main objectives for the project include:
\begin{itemize}
    \item Player Movement System
    \begin{itemize}
	\item{Create smooth movement mechanics including walking, running and jumping with proper animation blending.}
    \end{itemize}
    \item Combat System
    \begin{itemize}
	\item{Implement a basic combat system for player-enemy interactions including damage mechanics and animations for attacks, hits and deaths.}
    \end{itemize}
    \item Full User Interface
    \begin{itemize}
	\item{Implement a menu system with level selection, and a full heads up display during levels.}
    \end{itemize}
    \item Three Enemy Types
    \begin{itemize}
	\item{Create at least three types of enemies that have some variation in attack behaviours.}
    \end{itemize}
    \item Level Completion and Scoring system
    \begin{itemize}
	\item{Create scoring system based on defeated enemies, and implement end of level mechanic.}
    \end{itemize}
    \item Three Levels
    \begin{itemize}
	\item{Design three unique level layouts, increasing in difficulty.}
    \end{itemize}
    \item Music and Sound Effects
    \begin{itemize}
	\item{Add music and sound effects to the game for all scenes and events.}
    \end{itemize}
    \item Playable Build
    \begin{itemize}
	\item{Generate a functional game build for Windows that can be distributed for testing and feedback.}
    \end{itemize}
    \item Testing and Optimisation
    \begin{itemize}
	\item{Playtest the game with a few users to find and fix bugs, and optimise performance for smoother gameplay.}
    \end{itemize}
    \item Design Patterns
    \begin{itemize}
	\item{Refactor code into common design patterns where appropriate.}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
Game development is a multidisciplinary process that includes areas such as creating a game concept, designing its mechanics, and creating an engaging user interface and experience. Each of these elements are equally important to create a game that is accessible, enjoyable, and polished. This section covers the research that was carried out for the game, discussing the different approaches explored for various aspects of development. 

\section{Game Engines}
Game engines are platforms that make it easier to create computer games. They allow you to integrate and combine into single unit individual game elements such as animations, interaction with the user, or detection of collisions between objects \cite{Barczak2019}. These engines provide reusable components, allowing developers to focus on gameplay and design rather than redeveloping fundamental systems. There are many engines available, each suited to different types of projects. Popular engines for both 3D and 2D game development include Unreal Engine, Unity and Godot, while GameMaker and Construct are popular for 2D development. As this project is focused on 3D game development, my primary research concentrated on those engines.
\newline
Unreal Engine focuses on providing high-quality games with outstanding graphics and realism, thanks to its powerful graphics and rendering capabilities. Its Blueprint visual scripting system is a distinctive characteristic which allows programmers to build gameplay mechanics and events without writing any code. However Unreal Engine also provides the option to use C++ for more advanced customisation \cite{eventyr_2023}. While this engine offers many benefits, it comes with a very steep learning curve, as the interface and functionalities are intricate. Another drawback is that the software is resource intensive, requiring a more demanding system configuration for both gameplay and development \cite{eventyr_2023}. 
\newline
Unity is a powerful engine that is used by both small and large development studios. Its most prominent features are its user friendly interface, cross-platform compatibility, and powerful rendering and performance. It also provides a large asset library and extensive documentation. While Unity provides great performance and graphics, it is not an ideal choice for massive open worlds or intricate graphics as its performance is limited compared to that of Unreal Engine which is more suited to this type of game \cite{medium_2024}. Additionally, while Unity has a large user community and documentation, it can present a steep learning curve for those new to game development or programming, as it primarily uses C\# for scripting.
\newline
Godot is a versatile open-source game engine that offers 3D and 2D development. It offers a lightweight, user friendly interface and provides its own scripting language, GDScript which is beginner friendly. Godot also requires less power and expense to run in comparison to Unity and Unreal Engine. Some drawbacks of this engine are having a less extensive documentation and asset library in comparison to Unity and Unreal Engine, and is less suited to games that require a large range of functionality. \cite{hatton_2024}. \newline
For this game, the requirements include good tools and support for 3D development, an interface that is relatively beginner-friendly, and access to a large asset library, as I will not be creating the 3D models from scratch. Since a stylised visual style was chosen for the game, which gives a more cartoon-like look over realism, the project does not require an engine with advanced high-end graphics capabilities. Additionally, the decision to create contained levels instead of a large open-world environment means that the engine does not need to support expansive or highly complex environments.
Unity stands out as the best fit for these requirements due to its powerful 3D development capabilities, while being less resource intensive than Unreal Engine. Additionally, it is the most vastly documented engine of the three with a large asset store making it very accessible to learn and use.


\section{Design Patterns}
As programs get larger, it is critical to write code in such a way that classes and modules can communicate with each other in an intelligent way \cite{Doran2017}. In the context of game development, the complexity of the code can become large very fast, making it important to ensure that the code is clean, reusable, and scalable. Design patterns provide solutions to common design problems, enabling code to be easily extended and reused. It is important to create reusable components to reduce the amount of code that needs to be written for the game, and additionally design patterns make code easily extendable by designing it in such a way that adding new functionality does not require many changes to the existing functionality. There are many patterns that are widely used across many types of games, and this section will discuss the most relevant patterns to this genre of game.


\subsection{State Machines}\label{HSM}
State machines are a widely used design pattern in game development for managing objects that transition between predefined states. For example, a player character may switch between idle, walking, and running states based on user input. There are different variations of the state machine pattern, each addressing different levels of complexity in state transitions. These include the Finite State Machine (FSM), Concurrent State Machine (CSM), and Hierarchical State Machine (HSM). The FSM is the simplest of the three, ensuring that an object can transition between states while preventing multiple states from running simultaneously. This pattern solves two problems: an object should change its behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states \cite{unity2022_patterns}. This pattern works by defining an enum to represent a set of possible states such as walking, idle, or running, along with a state switching method that transitions between them based on specific conditions. This method determines which behaviour should be executed in each state. FSMs work well for managing a simple set of states that do not overlap or interfere with one another. However, it can become complicated when additional mechanics introduce their own state dependent behaviours that overlap with the current states. For example, if a player character needs to use a weapon that has its own states: idle, attacking, or reloading, adding these into the existing FSM would double the number of states, as each movement state (idle, walking, running) would need a second version that accounts for weapon handling \cite{nystrom2011game}. \newline
This issue is addressed by the Concurrent State Machine pattern. Instead of combining movement and weapon mechanics into a single FSM, a CSM allows multiple state machines to run independently. In this case, the player character would keep references to two separate state machines, one for movement states and another for weapon states that run concurrently. This allows states from both machines to overlap while keeping each set of states independent.
The Hierarchical State Machine (HSM) builds on the FSM by introducing a hierarchy of states, enabling shared behaviours across multiple states. This is especially useful when multiple states share common functionality. For example, all movement states that keep the player grounded need to apply gravity calculations. Instead of duplicating this logic in each movement state, it can be placed in a superstate which runs alongside its substates. In this case, the superstate would handle gravity calculations for the player, while the substates manage specific movement behaviours. 
\newline
The State pattern can be used to implement state machines as opposed to using enums to represent each state. This approach defines a base state class that all individual states inherit from, encapsulating state specific behaviour into dedicated classes. This makes the system more scalable for more complex and numerous states, as each state manages its own logic without relying on a large switch statement.  

\subsection{Observer}\label{observer}
The Observer Pattern is a behavioural design pattern used to manage communication between objects in a way that allows one object (the subject) to notify multiple other objects (the observers) when its state changes. This pattern is particularly useful in games where multiple objects need to react to specific events, such as changes in the player’s health, score, or game state. In the pattern there are two main components: the subject and the observers. The subject is the object that holds the state or data, which may change over time. When an event occurs, the subject notifies all registered observers. The observers on the other hand, listen for the event changes and define the actions they need to take when notified \cite{nystrom2011game}.
\newline
An example of its use in games would be a quest system where the quest progress is the subject, and several observers such as the quest tracker, the reward system, and quest related UI elements are notified whenever the player's progress on a quest changes. When the player completes an objective within the quest, the subject (the quest class) will notify the observers (quest tracker, reward system, UI elements), which then update themselves accordingly. This ensures that all components related to the quest are synchronised without the need for the subject to directly reference each observer.
\newline
The main benefit of using the Observer Pattern in game development is that it decouples the components of the game. The subject doesn’t need to know what each observer does, only that it needs to notify them when an event occurs. This means that the subject can focus on its core functionality, while the observers can be independent. Additionally, if new observers need to be added or existing ones modified, this can be done without changing the subject class, making the system more extendable and easier to maintain.
\newline
The Observer Pattern is also helpful in event driven systems. Games are often full of events, such as when a player picks up an item, takes damage, or completes a level. Instead of having the subject manage the responses for all these events, the Observer Pattern allows different parts of the game such as the UI, sound systems, or gameplay mechanics, to listen for and respond to the relevant events. This improves the scalability of the game’s architecture as more components are added.

\subsection{Strategy}\label{strategy}
The Strategy pattern is a design pattern used to define a family of behaviours and allows them to be interchangeable. In game development, this pattern is often used to handle different behaviours that an object can perform, such as various movement styles for enemies, different attack strategies for characters, or different types of player abilities. The way this pattern works is by defining a set of behaviours in separate classes, and let the client class decide which behaviour to use at runtime.
\newline
In an implementation of this pattern, the client class (like an enemy or player character) holds a reference to a strategy interface and uses it to perform a specific action, such as moving or attacking. The actual behaviour is defined in separate strategy classes, each of which implements the strategy interface. This means that the client class does not need to know the details of the behaviour, it just delegates the task to the strategy it has been assigned. This is especially useful in situations where an object may need to switch between different behaviours based on certain conditions during gameplay \cite{Doran2017}.
\newline
For example, an enemy character in a game may have different attack strategies, one for melee combat and another for ranged combat. By using the Strategy pattern, the enemy class doesn’t have to contain logic for both melee and ranged attacks. Instead, the enemy can switch between attack strategies by dynamically assigning a different strategy object, based on whether the player is close enough for a melee attack or far away for a ranged attack. This decouples the behaviour logic from the enemy class, making it easier to maintain and extend. This approach also allows for more flexibility and extendibility in the game's code. New behaviours can be added without modifying the existing class, and changes to existing behaviours only need to be made in the relevant strategy classes. 

\subsection{ObjectPool}\label{objectpool}
The Object Pool pattern is used to improve performance by efficiently reusing objects that are frequently created and destroyed. It is commonly used in game development to optimise the spawning of multiple entities, such as bullets shot from a gun or groups of enemies that continuously respawn. Instead of repeatedly creating and destroying new instances of these objects, the Object Pool keeps a finite amount of pre-created objects that can be reused when needed, improving memory performance.
\newline
To implement this pattern, two main components are required which are the object pool and the pooled object. The object pool is initialised with a specified size and creates a list of pooled objects. When an object is requested, the object pool checks for an available instance from this list and returns it for use. Once the object is no longer needed, it is returned to the pool where it is marked as available for use \cite{Doran2017}. 
\newline
A common example of this pattern in games would be a projectile system for a shooting mechanic. Instead of continuously creating and destroying projectiles, a fixed number of them are instantiated in the pool, defining the maximum number that can be active at one time. Once projectiles start firing, they are taken one by one from the pool. Once they have hit a target or disappeared, those instances are returned to the pool so that any new projectiles fired will reuse the same instances of the ones that have been disabled. 
\newline
The main way that this pattern optimises memory performance is by avoiding memory fragmentation. If instances of objects are being rapidly allocated and removed from memory, it can lead to the free space in the heap being broken into smaller pieces of memory instead of one large open block \cite{nystrom2011game}. The object pool avoids this by allocating a fixed amount of memory at the start of the game, which remains allocated until the game ends. During gameplay, objects within this pre-allocated memory are reused rather than continuously created and destroyed.

\subsection{Singleton}\label{singleton}

The Singleton pattern is a creational design pattern that ensures a class only has one instance and creates a global point of access to it. It is commonly used in games for managing systems that should only keep a single instance throughout the lifetime of the game, such as audio managers or input handlers.
Singleton instances are created using a static field within the class that stores the instance. In the constructor, if an instance already exists, the creation of a new one is prevented which ensures that only one instance is ever active at a time. Since the instance is globally accessible, any class can call it to use its methods \cite{Doran2017}. A common use case for the Singleton Pattern in games is managing game state. A game state manager tracks the current state of the game, such as whether it is running, paused, or in a menu. Since the game state must remain consistent across scenes, only one instance of the manager should exist to prevent conflicts or errors. By using a singleton, all relevant classes can access the manager globally to read and update the game state as needed. \newline
While Singletons can be convenient and easy to use, they can introduce problems in the long term. They are essentially a global variable, which have their own drawbacks such as making it harder to track down bugs, introducing coupling between classes, and they are not concurrency friendly. Because of this, it is important to ensure Singletons are used well and in the correct context, and alternative approaches should be considered in places where they are starting to introduce such problems.

\section{Optimisation Techniques}\label{optimisation}

Optimisation techniques are crucial in game development, as performance lag can significantly impact the player's gameplay experience in many game genres. In particular, 3D platformers require precise movement and jumps for navigating levels and obstacles, and experiencing frame drops can make the gameplay frustrating for the player. Some of the main optimisation techniques used for games are level of detail (LOD) management, occlusion culling and frustum culling. \newline
Occlusion Culling is the mechanism by which Unity avoids rendering computations for GameObjects that are fully hidden from view by other GameObjects \cite{Singh2022}. This means that if an object is within the camera's view but fully blocked by another object, it will not be rendered. By doing this, performance is significantly improved as resources are not wasted on elements outside of the player's immediate view. This technique is most beneficial in 3D games with large open world environments, indoor navigation, and densely structured shooter maps, where many objects may be hidden from view at any given time.
\newline
Frustum Culling is a technique similar to Occlusion Culling, aimed at optimising performance by preventing the rendering of game objects that are outside the camera's view (view frustum). When many active objects exist outside the player's field of vision, rendering them is unnecessary, as they are not visible. By culling these objects, the game avoids overprocessing and improves efficiency, especially for objects that are computationally expensive to render. This is done by identifying which objects are relevant to the current view by performing intersection checks against the view frustum \cite{FC2020}. \newline
Figure \ref{fig:FrustumCulling} illustrates the view frustum and the surrounding areas where different types of culling take place.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{OtherImages/ViewFrustum.png}
    \caption{Diagram representing different forms of culling. \cite{FC2020}.}
    \label{fig:FrustumCulling}
\end{figure}

LOD management is an optimisation technique that dynamically adjusts the complexity of an object's geometry based on its distance from the camera. In Unity, this is done by using LOD levels, which specify amount of detail of an object’s geometry to be rendered based on the object’s distance from the camera \cite{Unity2024LOD}. When an object is far from the player, a lower-detail version with fewer polygons is rendered, whereas a higher-detail version is used when the object is closer. This approach decreases the GPU's workload, freeing up resources for closer objects. This technique is particularly useful in expansive 3D environments, such as open-world games or any game featuring a vast, open map \cite{IndieGamesDevel}. Figure \ref{fig:LOD} displays three different 3D objects, each with different levels of detail. LOD 0 represents the highest quality model with the most polygons, while LOD 3 is the least detailed, with the fewest polygons.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{OtherImages/LOD.png}
    \caption{Varying levels of detail for 3D objects. \cite{LOD}.}
    \label{fig:LOD}
\end{figure}

\section{User Experience}\label{userexperience}
Creating an engaging and intuitive user interface (UI) and user experience (UX) is important in modern game development. 
UX in games includes the player's overall interaction with the game, including controls, interface design, camera systems, feedback mechanisms, and navigation flows \cite{Kramarzewski2023}. It focuses on ensuring that the game is enjoyable, accessible, and meets player expectations. 
\subsection{Camera and Controls}
Creating intuitive and easy to use controls enhances the player experience, preventing frustration and confusion from overly complex or unfamiliar controls. Designing effective input involves adhering to the principles of ergonomics and user expectations. Ergonomics refers to creating controls that are natural for hand movement, while user expectations involve using input controls that are familiar, so players can quickly learn the controls \cite{Rogers2014}. For example, the WASD keys on a keyboard are commonly used for movement in PC games because they are familiar to most players, and they allow a natural position for the hand on the keyboard. 3D platforming games typically use controller input rather than keyboard, as it allows smoother directional movement with a joystick as opposed to using arrow keys. Genres of games like First Person Shooters (FPS), and platformers have widely accepted control schemes, for example the spacebar on keyboard or X or A button on controllers usually makes the character jump in a platformer \cite{Rogers2014}. Figure \ref{fig:Controller} shows the most commonly used button assignments for game controllers in these genres. \newline
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{OtherImages/Controller.png}
    \caption{Common controller button assignments. \cite{Rogers2014}.}
    \label{fig:Controller}
\end{figure}
Camera systems are used in games to determine the player's perspective of the game world. The camera style in a game significantly influences both its design and control mapping. Therefore, choosing the right camera is crucial, as bad camera controls or perspective can frustrate players and make navigation confusing, affecting the overall user experience \cite{Rogers2014}.
\newline
Common types of camera include first-person, third-person and top-down cameras, each providing different approaches to the gameplay design \cite{Kramarzewski2023}. First person cameras show the game through the eyes of the player character, which offers a more immersive experience. These cameras provide easier aiming for weapons (in shooters), a closer view of weapons and world objects, and make it easier to create atmospheric scenes. However, they make it harder for players to judge jump and movement distances, and since the character is not visible, players may feel less emotionally connected to them. First person cameras are therefore commonly used for first-person shooter games like Call of Duty where precise aiming is important.
\newline 
Third person cameras are positioned slightly above and behind the player character which provides a wider view of the area with more focus on the player character. These cameras provide some advantages over first person cameras, such as providing a wider field of view for the player to anticipate situations, and a clearer view of the character, making movement distances easier to judge. However, they are generally less immersive than first person cameras. Third person cameras are typically used in adventure and 3D platforming games, such as The Legend of Zelda series and Super Mario Galaxy, where movement is more complex, and the design encourages players to form an emotional connection with the character. There are different ways of implementing third person cameras. Some remain fixed while following the player, while others allow player control to look around while still tracking the character. The choice between them depends on whether a full view of the surroundings is necessary. Some games take a hybrid approach, offering limited camera control to the player \cite{Hutchinson2009}.
\newline
Top down cameras provide a bird's eye view of the game world, positioned directly above the player looking down on them. There are some disadvantages that come with this view, such as not being able to get a good look at the character or the game world. \cite{Rogers2014}. Traditional top down views exist alongside a variation known as the top down/side view, which keeps the same camera angle but displays characters and entities from a side perspective. Top down cameras are typically used in a variety of game genres, including Stardew Valley, and the original Legend of Zelda.

\subsection{Level and UI Design}\label{level}
Level design is an important aspect of creating a compelling user experience in video games. It involves the structure and layout of the game world, including the placement of obstacles, collectibles and enemies, to provide an engaging and challenging experience for players. A well-designed level should balance challenge and accessibility, encouraging exploration and rewarding players for their progress \cite{Kramarzewski2023}. In 3D platformers and action-adventure games, levels are often designed to cater to both "achievers" and "experiencers", players who prefer completing tasks vs players who prefer exploration \cite{zhao2022dynamic}. This balance is achieved by designing levels with a core gameplay experience that is engaging for all players while incorporating hidden rewards and exploratory elements for experiencers. At the same time, achievers are provided with clear objectives, such as additional challenges, achievements, or opportunities to earn higher scores. 
\newline
Examples of games that take this approach are Super Mario 3D World and The Legend of Zelda: Breath of the Wild which both inspire the development of this game. Super Mario 3D World follows a linear level structure but includes hidden paths, collectibles, and optional challenges that reward players for exploring beyond the main route. Each level introduces new mechanics while maintaining a clear goal, appealing to both task focused players and those who enjoy discovering secrets.
The Legend of Zelda: Breath of the Wild takes a more open ended approach, allowing players to freely explore its vast world while subtly guiding them through with environmental cues and strategic enemy placement. Shrines and side quests serve as optional rewards that encourage exploration, while structured main quests provide a clear sense of progression.
\newline
Beyond the layout of game levels, the art style and overall aesthetic help to improve the user experience. High quality artwork can have a large impact on a game. It can draw a player into a game they might have otherwise overlooked, while making the game environment feel authentic and visually captivating. Additionally, a well-designed game world can create a unique atmosphere, which, when paired with the music and mechanics makes a really immersive experience. If the design of the game is visually appealing, players are more likely to tolerate imperfections in the gameplay \cite{Jesse2019}. \newline

The design of the user interface (UI) is important for enhancing the user experience, as it ensures the player can easily navigate the game and receive clear visual feedback to validate their actions. The user interface in video games consists of the heads up display (HUD) and various other screens, such as game over screens, settings menus, and pause menus. The HUD refers to the visual screen overlay that communicates information to the player during gameplay. Typical elements found on the HUD in 3D platforming and action-adventure games are health bars/lives, a map, quest information, and score information \cite{Rogers2014}. The HUD should display relevant information to the player but should not clutter the view of the game too much. For the layout of information on the HUD, it is important to prioritize an information hierarchy to ensure that the most important information stands out and is easily accessible to players. The elements should be arranged in a logical way, with the most important information placed in prominent positions on the screen \cite{Hive}. An example of an effective HUD in a 3D platforming game is found in Super Mario Odyssey. Its clear and concise design communicates essential information without obstructing the gameplay, ensuring that the player remains immersed in the game world. This is illustrated in Figure \ref{fig:MarioHUD}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{OtherImages/MarioOdysseyHUD.jpeg}
    \caption{HUD display from Super Mario Odyssey}
    \label{fig:MarioHUD}
\end{figure}

For other UI screens, the same principles of visual aesthetics and coherence with the game’s aesthetic are important, just as much as for level design. A well designed user interface should be ergonomic, being intuitive and easy to navigate using the given input controls. In game development, this is typically achieved through the use of wireframes, which are storyboards mapping out user interaction flows \cite{Rogers2014}. These wireframes include drawings that depict screen transitions, button interactions, item pickups, and more, and are later transformed into functional prototypes that are play tested to refine the usability and appeal of the interface.\newline
Icon design also plays an important role in the usability design of a game's UI. Since games often require many icons to represent different actions or elements, clear and useful icons are crucial. Important considerations include selecting recognisable images, using consistent colour coding, and using background shapes to distinguish categories or functions. Icons should be familiar and immediately understandable such as the cogwheel commonly used to represent settings in most software applications. Colour and shape not only aid recognition but can be used strategically to draw attention to various elements based on their importance or intended use \cite{Rogers2014}.

%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in Section \ref{HSM}.  A HSM was implemented for the player's movement as there was shared behaviour that needed to be applied across multiple states without duplicating it into each one. For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure \ref{fig:label_State} details this architecture:

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_State}
\end{figure}

The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and its Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. The factory pattern was used here for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}\label{physics}
In the game, Unity's built in Character Controller was used for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics \cite{unity2024_charactercontroller}. In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In the game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why the built-in Character Controller was chosen, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk upstairs and walk on slopes \cite{unity2024_charactercontroller_reference}. The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. This was used for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so the gravity and jump mechanics were implemented separately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, the following equations outlined by Kyle Pittman were used \cite{pittman2016_jump}, detailed in Figure \ref{equations}.
\begin{figure}[H]
	\begin{equation}
	\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
	\end{equation}

	\begin{equation}
	\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
	\end{equation}
	\caption{Equations for parabolic jump motion.}
	\label{equations}
\end{figure}


\paragraph{}
\begin{figure}[H]
	\begin{verbatim}
	private void SetupJumpVariables()
	{
	    float timeToApex = _maxJumpTime / 2;
	    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
	    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
	}
	\end{verbatim}
	\caption{Application of jump equations in the code.}
\end{figure}
For the gravity applied to the player while grounded, a smaller value of gravity was used to avoid unnecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

%%%%%%%%%%%%%%%%%%%%%%
%%% Enemies and Combat#
\section{Enemy Movement}\label{enemy_movement}
The enemy movement in the game is implemented dynamically based on the player's proximity. There are two enemy types, long range and short range which both exhibit different movement behaviours. Short ranged enemies start in an idle state and begin to chase the player when they come within a specified range. Once the player moves out of this range, the enemies return back to their original starting position. Long ranged enemies that shoot the player from a distance stand still, and dynamically rotate to face and aim at the player. To implement this behaviour with intelligent navigation, Unity's AI module was used, which supports AI pathfinding using NavMesh Surfaces and NavMeshAgents \cite{unity2024_AI}. 
A NavMeshAgent is assigned to each enemy, allowing them to navigate across a NavMeshSurface while avoiding obstacles in their path. These agents are configured with properties such as movement speed, acceleration, avoidance priority, and movement radius, which control their movement behaviour \cite{unity2024_NavAgent}. The NavMeshSurface is assigned to the level's entire terrain, defining the ground area that the enemies can move on. This approach allows enemies to intelligently avoid obstacles and dynamically chase the player while navigating complex environments. \newline
\subsection{Architecture}
Unlike the player movement system, the State Machine design pattern was not used for the enemy movement states. The enemy states: Idle, Chasing and Returning are relatively simple, and using a State Machine would likely overcomplicate the system for such few states. The current design is detailed in Figure \ref{fig:label_enemyMovement}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyMovementUML.drawio}
    \caption{UML Class digram of Enemy Movement System}
    \label{fig:label_enemyMovement}
\end{figure}
The FollowRadius component detects when the player enters or exits the proximity radius. It makes use of a SphereCollider which calls OnTriggerEnter() and OnTriggerExit() when the player enters or exits the radius. It communicates this to EnemyMovement using events. The OnTriggerEnter() method is detailed in Figure \ref{ontriggerenter}.

\begin{figure}[H]
\begin{verbatim}
private void OnTriggerEnter(Collider other) 
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if (damageable != null)
    {
        PlayerEnter?.Invoke();
    }
}
\end{verbatim}
\caption{OnTriggerEnter() method from the FollowRadius class.}
\label{ontriggerenter}
\end{figure}

EnemyMovement subscribes to the PlayerEnter and PlayerExit events from FollowRadius and manages the enemy's movement coroutines based on the event. A coroutine is a method that allows you to spread tasks across several frames. It can pause execution and return control to Unity but then continue where it left off on the following frame \cite{unity2024_Coroutines}. Coroutines were used instead of the Update() method which runs every frame. This is because the enemy movement relies on constant checks for position updates such as the player's position to follow, and using a coroutine allows this behaviour to execute over time without repeatedly checking every frame. One of the coroutines from EnemyMovement is detailed in Figure \ref{followtarget}.
\begin{figure}[H]
\begin{verbatim}
private IEnumerator FollowTarget()
{
    WaitForSeconds wait = new WaitForSeconds(_updateSpeed);
    while(enabled){
        if (Target != null)
        {
            _isMoving = _agent.velocity.magnitude > 0.1f;
            _animator.SetBool(_isMovingHash, _isMoving);
            _agent.SetDestination(Target.position); 
        }
        yield return wait;
    }
}
\end{verbatim}
\caption{FollowTarget() method from the EnemyMovement class.}
\label{followtarget}
\end{figure}

RangedEnemyMovement inherits from EnemyMovement, allowing different movement behaviour for long ranged enemies. It overrides the OnPlayerEntered and OnPlayerExit methods from EnemyMovement to start and stop an aiming coroutine when the player enters or exits the FollowRadius. This enables the Enemy class to use two different movement types interchangeably depending on the enemy type, similarly to the strategy pattern.
The Enemy class manages the overall behaviour and state of the enemies in the game. Concerning movement, it is responsible for configuring the properties of the NavMeshAgent (such as speed and stopping distance) but delegates the actual movement logic to the EnemyMovement or RangedEnemyMovement classes. This separation allows the Enemy class to keep its focus on managing overall enemy behaviours while delegating the more complex logic to other dedicated classes. For movement, it works with the EnemyMovement class, while for combat, it interacts with the AttackRadius class (Detailed in Section \ref{combatsystem}). 

\subsection{Configurable Enemies}
Currently in the game there are three enemy types, Goblin Warrior, Scout and Archer. Warrior and Scout are both  short range and vary in attack speed, health and movement speed. Archer is a long ranged enemy with differing attack speed, health, and movement properties to Warrior and Scout. To enable multiple enemy types the Strategy pattern was used, as discussed in Section \ref{strategy}, in conjunction with Unity's ScriptableObject feature. Strategy was used here to enable the Enemy class to use different behaviours interchangeably without hardcoding multiple Enemy classes for different enemy types. Unity's ScriptableObject is a data container that allows you to create customisable assets in the Unity editor \cite{unity2024_ScriptableObject}. This was used along with the Strategy pattern methodology to create separate configurable data containers for the three different enemy types. This design is detailed in Figure \ref{fig:label_strategy}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyStrategyUML.drawio}
    \caption{UML Class diagram of Enemy Strategy Pattern.}
    \label{fig:label_strategy}
\end{figure}
The EnemyScriptableObject stores all the customizable parameters, such as health, attack speed, and movement speed. The Enemy class uses the data from the assigned ScriptableObject (GoblinWarrior, GoblinScout for GoblinArcher) to adjust its behaviour dynamically. This approach decouples the enemy configuration from the core enemy logic, allowing new enemy types to be added easily by creating new ScriptableObjects without modifying the Enemy class. 

\section{Combat System}\label{combatsystem}
The combat system is a core feature of the game, enabling attack and damage mechanics between the player and enemies. The design focusses on handling the damage mechanic in a consistent way across both enemies and player, while accommodating their differing attack mechanics. This was achieved by creating an IDamageable interface, which must be implemented by all game objects capable of taking damage. This design is detailed in Figure  \ref{fig:label_combat}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/CombatUML.drawio.png}
    \caption{UML Class diagram of Combat System}
    \label{fig:label_combat}
\end{figure}
The IDamageable interface is the core of the system, which defines a TakeDamage() method which reduces the entity's health based on an incoming damage value. Both the Enemy and PlayerHealthAndDamage classes implement this interface, ensuring damage is applied in a consistent way for both entities. 
\newline The player's combat mechanic is controlled by the WeaponAttributes class. The weapon is equipped with a Box Collider that calls the OnTriggerEnter() method on collision. Within OnTriggerEnter(), the TakeDamage() method is called on the enemy that entered the collider. This is detailed in Figure \ref{ontriggerenter2} 
\begin{figure}[H]
\begin{verbatim}
private void OnTriggerEnter(Collider other)
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if(damageable != null)
    {
        // Call takedamage method on enemy
        damageable.TakeDamage(damage);
    }
}
\end{verbatim}
\caption{OnTriggerEnter method from the WeaponAttributes class.}
\label{ontriggerenter2}
\end{figure}
The WeaponManager class manages the weapon's Box Collider, ensuring that it is only enabled during the player's attack animation. This is achieved with Unity animation events, which call the EnableWeaponCollider() method at the appropriate time during the attack animation.\newline 
The enemy's combat system differs from the player's, as it does not rely on weapon collision mechanics. Instead, the AttackRadius class manages the enemy's attack behaviour. This system uses a Sphere Collider that defines a radius in which the player can take damage. When the player is within this radius, the enemy periodically attacks by calling the player's TakeDamage() method. The  attacks are based on a set delay, allowing different enemy types to vary in attack speed. The Attack coroutine from AttackRadius is detailed in Figure \ref{attackradius}.

\begin{figure}[H]
\begin{verbatim}
protected virtual IEnumerator Attack()
{
    WaitForSeconds wait = new WaitForSeconds(_attackDelay);

    // Keep attacking as long as the player is within the radius and the enemy can attack
    while (_damageable != null)
    {
        if (GetComponentInParent<Enemy>().CanAttack)
        {
            OnAttack?.Invoke(_damageable);
            _damageable.TakeDamage(_damage);
        }
        yield return wait; // Wait before the next attack
    }

    _attackCoroutine = null;
}
\end{verbatim}
\caption{Attack() coroutine from the AttackRadius class.}
\label{attackradius}
\end{figure}

All enemy types in the game can be stunned after being hit by the player. When stunned, enemies are unable to attack until the 'get hit' animation has ended. This is controlled by a CanAttack variable defined in the Enemy class, which is checked in the Attack coroutine to determine when the enemy can attack. RangedAttackRadius provides the attack logic for the Archer enemy, which inherits from AttackRadius. This enemy begins firing arrows periodically while aiming at the player when the player has entered the RangedAttackRadius, and stops when they've left the radius. To achieve this behaviour, the Object Pool pattern was used, as discussed in Section \ref{objectpool}, to manage the creation of arrows. This pattern avoids repeatedly creating and destroying arrows, improving performance. The architecture for this is shown in Figure \ref{fig:label_objpool} below.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/ArrowPoolUML.drawio.png}
    \caption{UML Class diagram of Object Pool Pattern}
    \label{fig:label_objpool}
\end{figure}
The ObjectPool class manages a pool of reusable objects, which in this case would be the arrows. It keeps a list (\_availableObjectsPool) of available objects to be used, and provides methods for creating a pool of objects, getting an available object to use from that pool and returning already used objects back to the pool. PoolableObject represents an object to be used in the object pool, defining a method to ensure objects that inherit from this class are returned to the object pool once disabled. The Arrow class manages the arrow prefab that will be used in the object pool, which inherits from PoolableObject. It defines all of the arrow's properties and handles dealing damage to the player on collision. RangedAttackRadius overrides the Attack coroutine from AttackRadius to implement this new behaviour, detailed in Figure \ref{attackcoroutine2}.

\begin{figure}[H]
\begin{verbatim}
protected override IEnumerator Attack()
{
    WaitForSeconds Wait = new WaitForSeconds(_attackDelay);
    yield return Wait;

    // Continue attacking while there is still a target
    while (_damageable != null)
    {
        _agent.isStopped = true;

        // Get an available arrow from the pool
        PoolableObject poolableObject = _arrowPool.GetObject();
        if (poolableObject != null)
        {
            // Set up the arrow's properties
            _arrow = poolableObject.GetComponent<Arrow>();
            _arrow.Damage = _damage;
            _arrow.transform.position = transform.TransformPoint(_arrowSpawnOffset);
            _arrow.transform.rotation = _agent.transform.rotation;

            // Apply force to the arrow in the direction that the enemy is facing
            _arrow.Rigidbody.AddForce(_agent.transform.forward * 
			_arrowPrefab.MoveSpeed, ForceMode.VelocityChange);
            InvokeOnAttack(_damageable);
        }
            
        yield return Wait;
    }

    _attackCoroutine = null;
}
\end{verbatim}
\caption{Attack() coroutine from the RangedAttackRadius class.}
\label{attackcoroutine2}
\end{figure}

Each time the ranged enemy attacks, it gets a new available arrow from the object pool using GetObject(). Then, the properties of the arrow are configured, including the damage it does and its spawn position in relation to the enemy. The Arrow prefab uses a Rigidbody component, as discussed in Section \ref{physics}, which allows it to use and react to physics. This allows for a force to be applied to the arrow, shooting it in the direction of the player at a specific speed. 

%%%%%%%%%%%%%%%%%%%%%%
%%% Animals and Cages
\section{Animals and Cages}
The main gameplay mechanic of the game is rescuing animals around the map. In each level there are three animals stuck within cages that are guarded by enemies for the player to find and rescue. To rescue an animal the player has to defeat the enemies that surround the animal's cage. The amount of enemies surrounding each cage varies to increase/decrease the difficulty of the parts of each level. Once the player rescues an animal they break free from the cage and follow the player around the map. The architecture of this mechanic is detailed in Figure \ref{fig:label_rescue} below. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/AnimalRescueUML.drawio.png}
    \caption{UML Class diagram of Animal Rescue Mechanic}
    \label{fig:label_rescue}
\end{figure}
The Cage class controls the logic for freeing animals once all assigned enemies have been defeated. Each cage has a list of associated Enemy objects that are assigned to each specific cage in the Unity editor. The class subscribes to the OnDefeated event of each of its associated enemies, allowing it to be notified when one of them dies. Each time OnEnemyDefeated is triggered, the cage checks if all assigned enemies in the list have been defeated. Once this condition is met, the FreeAnimal() method is called, which handles the visual and sound effects for the cage's destruction and prompts the animal to start moving. The Animal class manages this movement behavior which includes staying idle inside the cage until freed. Once freed, the Cage script calls the Animal's StartFollowing() method which allows the Animal to follow the player. The follow movement uses the same logic that the Enemy movement uses to chase the player, discussed in Section \ref{enemy_movement}. To prevent animals from getting stuck around the map far from the player, a teleportation system ensures they remain near the player. The TeleportRadius class represents a sphere collider around the player for this system. If an animal exits this radius, it calls the Animal's TeleportToPlayer() method, ensuring they stay within a reasonable distance of the player.

%%%%%%%%%%%%%%%%%%%%%%
%%% User Experience#
\section{User Interface}
The design of the user interface (UI) is an important part of enhancing the overall user experience for the game, as discussed in Section \ref{userexperience}. Therefore creating a full UI was a large focus of the development to achieve a complete and professional looking game that is intuitive for the player to use. The UI includes a title screen, level selection menu, settings and pause menus and a HUD (Heads Up Display) for the levels.  \newline
To set up the UI components, Unity's built-in UI package was used \cite{unity2024_UI} to create multiple canvases to display various types of information to the user. 
For communication between the UI elements involving health changes and relevant game objects, the Observer pattern was used, as discussed in Section \ref{observer}. The pattern was used in this context to decouple the UI components from the game logic. This allows the game objects to act as subjects, and notify the relevant UI components (observers) without needing to hold direct references to them. Currently, there are two subjects (the enemy and player), and three observers (the enemy and player's health bars and the game over screen). This design is shown in Figure \ref{fig:label_observer1}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/HealthObserverUML.drawio.png}
    \caption{UML Class diagram of Health Observer Pattern}
    \label{fig:label_observer1}
\end{figure}
There are two interfaces to manage health changes: one for the subject and one for the observers. The IHealthSubject interface defines methods for registering, unregistering and notifying observers about health changes. The IHealthObserver interface specifies an OnNotify() method, that passes the observer the updated health value and defines what it should do given the new value. 
The PlayerHealthAndDamage and Enemy classes implement the IHealthSubject interface. Each holds a list of observers that are managed with the register and unregister observer methods. When a health change happens, the subjects notify their observers by calling the OnNotify() method for each observer in the list. An example of this is detailed in Figure \ref{notifyhealthobservers}.
\begin{figure}[H]
\begin{verbatim}
public void NotifyHealthObservers()
{
    foreach (IHealthObserver observer in _observers)
    {
        observer.OnNotify(_maxHealth, _health);
    }
}
\end{verbatim}
\caption{NotifyHealthObservers() method from the PlayerHealthAndDamage class.}
\label{notifyhealthobservers}
\end{figure}
The PlayerHealthBar, EnemyHealthBar and GameOver classes implement the IHealthObserver interface. The Game Over screen needs to observe the player's health and subsequently pop up if their health is below zero. 
The health bars observe the player and enemies to display their current health in real time. Each observer registers itself with its associated subject by calling the subject's RegisterHealthObserver(this) method. Once registered, the subject calls the observer's OnNotify() method whenever there is a health update. For example, when an Enemy notifies the EnemyHealthBar, the following method detailed in Figure \ref{onnotify} is called.
\begin{figure}[H]
\begin{verbatim}
public void OnNotify(float maxHealth, float currentHealth)
{
    UpdateHealthBar(maxHealth, currentHealth);
}
\end{verbatim}
\caption{OnNotify() method from the EnemyHealthBar class.}
\label{onnotify}
\end{figure}
Beyond the player and enemy health bars, additional UI elements are displayed on the HUD to communicate the player's progression through the level. At the start of a level, the HUD displays the current objective: "Rescue the animals". Then, as animals are rescued, the HUD updates dynamically to display the number rescued out of the total. Once all animals have been freed, the objective changes to "Get to the goal," and the goal is activated with a collider and visual effects to highlight its location. When the player walks into the goal collider, a level cleared screen appears, displaying the player's time and score. These events are shown in Figures \ref{fig:label_goal} and \ref{fig:label_levelcleared}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/Goal.png}
    \caption{Goal Activated}
    \label{fig:label_goal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelComplete.png}
    \caption{Level Cleared Screen}
    \label{fig:label_levelcleared}
\end{figure}

The architecture for the level progression is detailed in Figure \ref{fig:label_levelprogression} below.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelProgressionUML.drawio.png}
    \caption{UML Class diagram of Level Progression}
    \label{fig:label_levelprogression}
\end{figure}

The UIQuestManager manages the quest system by tracking the number of rescued animals, updating the quest dialog, and activating the goal when all animals have been freed. The Animal class defines an OnRescued event, which UIQuestManager subscribes to in order to be notified whenever an animal is rescued. Each time UIQuestManager is notified of this event, it updates the count on the HUD and checks whether all animals have been rescued. If so, it changes the quest dialog and activates the goal. The OnAnimalRescued method, which handles this logic, is shown in Figure \ref{onanimalrescued}.
\begin{figure}[H]
\begin{verbatim}
private void OnAnimalRescued()
{
    _rescuedAnimals++;
    _rescuedAnimalsText.text = $"{_rescuedAnimals}/{TotalAnimalsToRescue}"; // Update UI

    // If all animals have been rescued, show new quest and activate the goal
    if (_rescuedAnimals >= _totalAnimalsToRescue && !_allAnimalsRescued)
    {
        _allAnimalsRescued = true;
        StartCoroutine(TransitionToSecondQuest());
        ActivateGoal();
    }
}
\end{verbatim}
\caption{OnAnimalRescued() method from the UIQuestManager class.}
\label{onanimalrescued}
\end{figure}
The ActivateGoal() method enables the GoalRadius object and instantiates the visual effect that signals the goal’s activation. GoalRadius represents the collider that the player must enter to complete the level. When the player collides with it, the OnTriggerEnter() method triggers the Setup() method in the LevelCleared class, which manages the level completion screen.
LevelCleared retrieves the elapsed time from GameTimer and the total score from the ScoreManager to display them on the UI. The ScoreManager tracks the player’s score throughout the level by subscribing to the Enemy class's OnDefeat event. Each time an enemy is defeated, its score is added to the total. When LevelCleared retrieves this value, it combines it with the completion time and applies a score multiplier, rewarding players for defeating more enemies and finishing the level quickly. The Setup() method from LevelCleared, which handles this logic, is shown in Figure \ref{setup}.

\begin{figure}[H]
\begin{verbatim}
public void Setup()
{
    // Activate the UI screen and change the game state
    gameObject.SetActive(true);
    LevelManager.Instance.SetGameState(LevelState.LevelCleared);

    // Play sound effect
    SoundFXManager.instance.PlaySoundFX(_levelClearedClip, transform, 1f);

    // Get the time from the game timer and convert it to minutes and seconds
    float elapsedTime = _timer.ElapsedTime;
    int minutes = Mathf.FloorToInt(elapsedTime / 60);
    int seconds = Mathf.FloorToInt(elapsedTime % 60);
    _timeText.text = $"{minutes:D2}:{seconds:D2}";

    // Get score from the score manager and add on the elapsed time
    float finalScore = (_score.Score + elapsedTime) * 10;
    _scoreText.text = $"{finalScore:N0}";
}
\end{verbatim}
\caption{Setup() method from the LevelCleared class.}
\label{setup}
\end{figure}

Another important aspect of the UI is managing gameplay pausing during specific UI screens, such as the pause menu or game over screen, and allowing different classes to respond based on the current game state. To achieve this, the LevelManager class handles transitions between the key game states: Playing, Paused, LevelCleared, and GameOver.
This class uses the Singleton pattern, as discussed in Section \ref{singleton}, ensuring that the game state can be read globally without requiring direct references in multiple classes. Additionally, it guarantees that only one instance of LevelManager exists per level. The architecture of this system is illustrated in Figure \ref{fig:label_singletonLevelManager}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelManagerSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonLevelManager}
\end{figure}

The LevelManager implements a simple Finite State Machine (FSM) as discussed in Section \ref{HSM} , managing game states using a LevelState enum to represent each level state, as each state requires minimal behavior. The SetGameState() method transitions the game to a new LevelState when called, typically triggered by UI screens associated with those states. For example, when the pause menu is activated, it calls \newline \texttt{LevelManager.Instance.SetGameState(LevelState.Paused)}, and the LevelManager handles pausing the game accordingly. Within SetGameState(), the method determines the new state and executes the appropriate logic. For instance, in the Paused state, EnableGameplay() is called to stop gameplay. Additionally, other classes can query the LevelManager to check the current game state, allowing them to execute state-specific logic only when necessary.\newline

The game also implements animated scene transitions to create a smoother and more visually appealing UI experience when navigating through menus for the user. Initially, each UI menu class contained its own button logic for loading scenes, resulting in duplicated code across multiple menu classes. The Title Screen, Level Select and each level are each a seperate scene, so most buttons, except for the pause and resume buttons within a level, take the user to a different scene. To improve maintainability and implement animated scene transitions, the button logic was refactored into a dedicated SceneLoader class. The architecture of this class is illustrated in Figure \ref{fig:label_SceneLoader} below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{UMLDiagrams/SceneLoaderUML.drawio.png}
    \caption{UML Class diagram of SceneLoader class}
    \label{fig:label_SceneLoader}
\end{figure}

In Unity, UI buttons are components that can be attached to UI objects in a scene, each with an OnClick event that allows a method from any class to be assigned. In the game, all UI buttons reference the SceneLoader class in their OnClick events, ensuring a consistent approach to scene transitions. The SceneLoader class provides a LoadScene() method, which takes the name of the scene to load as a string, triggers the transition animation, and then loads the new scene. It also includes an ExitGame() method for buttons that allow the player to quit the game. The transition animation is handled by an object with an Animator component. When a scene loads, this object starts by covering the screen and then plays an animation to reveal the new scene. Within SceneLoader, when a button is pressed, the animator is triggered to play the 'hide' animation, and the scene transition is delayed for the duration of this animation before the new scene is loaded. This ensures smooth and visually appealing transitions between UI screens.

\section{User Experience}\label{UX}
User experience focuses on ensuring that the game is enjoyable and accessible for the player, which includes considerations for controls, camera movement, feedback mechanisms and interface design, as discussed in Section \ref{userexperience}. In the second term of the project, beta testing was carried out which included a user feedback form that was sent out to gather player opinions on the game. The insights from this feedback will be discussed throughout this Section, and the beta testing process is discussed in further detail in Section \ref{testing}.

\subsection{Camera \& Controls}
For the camera movement, a fixed third-person perspective was implemented, as discussed in Section \ref{userexperience}.  The camera stays positioned behind the player and follows their movements without allowing the player to control its angle or view. 
This camera perspective was chosen because it is the approach used in the games that this project takes inspiration from, Super Mario 3D World and The Legend of Zelda: Link’s Awakening for Switch. Given the relatively small level sizes, full camera control is unnecessary, as the fixed perspective provides a clear view of most of the environment. Additionally, the third-person view ensures that the player can clearly see their character’s movements, which is essential for both platforming and action gameplay.
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/PlayerCamera.png}
        \caption{FreeLook Camera on Player}
        \label{fig:label_camera}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/Zelda.png}
        \caption{Camera from Link's Awakening}
        \label{fig:label_linkcamera}
    \end{subfigure}
    \caption{Comparison of the game's camera system with Link's Awakening}
\end{figure}

To achieve smooth and dynamic camera movement for this scenario, Unity's Cinemachine package was used. Cinemachine allows you to create professional looking camera movement with automatic damping and target tracking \cite{onewheelstudio_2021}. The FreeLook camera that Cinemachine provides was used to create the third person camera as shown in Figure \ref{fig:label_camera}
Cinemachine allows you to define different camera properties such as follow speed and field of view to achieve the best perspective that would show a sufficient view of the world within the camera. \newline
As discussed in Section \ref{userexperience}, player controls are an important factor towards offering a great user experience. To allow the player to use either keyboard inputs or game controller inputs, Unity's new Input System was used. The input system allows players to control the game in a variety of ways including external devices, touch screen or gestures \cite{unity_2024_inputsystem}. This is done by setting up 'Actions' such as running, which can have multiple input options linked to it. For example the run action is linked to both the Left Shift key on the keyboard, and the Left Trigger button on a controller. Below is an example of how the directional movement input is read using the corresponding input action, detailed in Figure \ref{onmovementinput}.

\begin{figure}[H]
\begin{verbatim}
private void OnMovementInput(InputAction.CallbackContext context)
{
    Vector2 input = context.ReadValue<Vector2>();
    _currentMovementInput = input;
    _isMovementPressed = input != Vector2.zero;
}
\end{verbatim}
\caption{OnMovementInput() method from the PlayerStateMachine class.}
\label{onmovementinput}
\end{figure}
OnMovementInput is triggered when the movement input action is performed (Joystick or WASD key movements) and provides 'context' of the action. In this case we read the input as a two dimensional vector in the direction that the player is pressing, which is then used for the Move() method of the Character Controller (Discussed in Section \ref{physics}). 

\subsection{Level Design}\label{leveldesign}
One of the objectives for the project surrounding user experience was to design three levels of varying difficulty. A key aspect of level design is to keep a balance between challenge and accessibility for all levels of players as discussed in Section \ref{userexperience}. Since this game is aimed at all ages, it was important to start with a very easy introduction and gradually increase the difficulty. The three levels are of progressive difficulty, with the first level starting as an introduction to the game’s mechanics. Ideally, with more time, this could have been expanded into a dedicated tutorial level with full instructions on controls and core mechanics. For now, level one is designed to be linear, ensuring that players naturally encounter animals to rescue and enemies to fight without needing to search for them. The first enemies appear individually and are easy to defeat, allowing the player to learn combat mechanics in a low pressure environment. Additionally, two collectible hearts are placed in accessible locations to help players restore their health as they progress. An overview of this level is shown in Figure \ref{fig:label_LevelOne}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelOne.png}
    \caption{Overview of Level One Layout}
    \label{fig:label_LevelOne}
\end{figure}

The second and third levels increase in difficulty compared to the first, with groups of two enemies guarding most cages. Unlike level one, these levels are less linear, requiring more exploration to find collectible hearts and animals to rescue. Level three presents the greatest challenge, incorporating more difficult platforming sections and additional enemies beyond those guarding cages, encouraging players to engage in combat for a higher score. This level design aimed to keep a balance between platforming and exploration while keeping the environments fairly small to maintain a short and light hearted gameplay experience. An overview of these levels are shown in Figures \ref{fig:label_LevelTwo} and \ref{fig:label_LevelThree}. \newline

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelTwo.png}
    \caption{Overview of Level Two Layout}
    \label{fig:label_LevelTwo}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelThree.png}
    \caption{Overview of Level Three Layout}
    \label{fig:label_LevelThree}
\end{figure}

In the user feedback collected during term two, players were asked whether they found the gameplay enjoyable. The results of this assessment are shown in Figure \ref{fig:label_funfeedback}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/EnjoyableFeedback.png}
    \caption{User Feedback Survey Results: Gameplay}
    \label{fig:label_funfeedback}
\end{figure}
The results ranged from neutral to strongly agree, with no users expressing disagreement, indicating that all participants found the gameplay at least somewhat enjoyable. When asked for additional feedback on this topic, two users specifically mentioned that they enjoyed the platforming elements and found the player’s movement system fun to use. Some users suggested that introducing more weapon types or attack variations could enhance the gameplay experience. Another user highlighted the game’s cute art style, stating that rescuing the animals felt rewarding. Based on this feedback, it would seem the thing most lacking from a fun gameplay experience is more variation in the combat system. Based on this feedback, the main area for improvement in the gameplay experience appears to be more variety in the combat system. Given more time, adding new attack options for the player, such as a bow and arrow, or introducing a wider range of enemy types could help to improve the overall user experience. \newline
Across all levels, each type of enemy keep the same health and damage values, determining how much damage they deal to the player and how difficult they are to defeat. Similarly, the player has fixed health and attack statistics. Balancing these values was a challenge, as it was important to ensure that enemies were neither too easy or too difficult to defeat, and similarly for the player character. These values were refined through playtesting conducted in the first term of the project, as discussed in Section \ref{testing}, where feedback was gathered informally from a few users on how the difficulty could be adjusted. This continued in the second term with more formalised feedback via the beta testing user feedback form. The results indicated that the majority of players found the gameplay to be easy, as shown in Figure \ref{fig:label_difficultyfeedback}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/DifficultyFeedback.png}
    \caption{User Feedback Survey Results: Difficulty}
    \label{fig:label_difficultyfeedback}
\end{figure}

When asked to provide additional feedback on difficulty, three users suggested increasing the enemy difficulty, either by raising their attack power or increasing their numbers in each level. Based on this feedback, the attack power of two of the weaker enemies (archer and scout) was increased to make them more challenging for the player. However, achieving a perfect balance would require further rounds of playtesting and feedback.

\subsection{UI Design}\label{UIDesign}

The game features a complete UI, including a HUD, title screen, level select menu, game over screen, pause menu, settings menu, and level cleared screen, all with animated scene transitions. The design and layout of these elements were chosen and refined through rounds of playtesting and beta testing. In particular, the HUD's layout and choice of elements were critical design decisions, ensuring that it effectively conveys relevant information to assist the player throughout each level.
\newline
The HUD elements selected for the game include health bars for both the player and enemies, an animal rescue counter, a quest tracker, and a game timer. The layout and design of these elements changed over the course of development, leading to some significant adjustments. Initially, the health bar had a different design and was positioned in the top left corner of the screen. However, based on user feedback, it was determined that placing the quest information in the top left was more effective, as players naturally focused their attention on the upper half of the screen.
\newline
As more HUD elements were introduced, such as the quest tracker, inconsistencies in their design made the interface appear cluttered and visually incohesive. To address this, a UI pack from the Unity Asset Store was used to standardise the design of all HUD and UI elements, ensuring they had a unified and polished look that matched the game’s overall aesthetic. The importance of maintaining visual consistency in UI design is discussed further in Section \ref{level}. Similarly, for the other UI screens, their design was changed throughout development to include different buttons and information. The original level cleared screen featured only restart and exit game buttons, before other UI like the main menus were added. Examples of the old vs new UI screens are shown in Figure \ref{fig:hud_comparison}.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{OtherImages/OriginalHUD.png}
        \caption{Old HUD Design}
        \label{fig:old_hud}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{OtherImages/HUD.png}
        \caption{New HUD Design}
        \label{fig:new_hud}
    \end{subfigure}
    
    \vspace{1em} % Adds some vertical spacing

    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{OtherImages/OriginalLevelCleared.png}
        \caption{Old Level Complete Screen}
        \label{fig:old_complete}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{OtherImages/LevelComplete.png}
        \caption{New Level Complete Screen}
        \label{fig:new_complete}
    \end{subfigure}

    \caption{Comparison of Old and New HUD and Level Complete Screens}
    \label{fig:hud_comparison}
\end{figure}
The UI screens were designed to be minimalistic to make it easier for players to use, with limited button presses needed to get between screens. The buttons have clear and familiar icons to indicate what they do. The importance of familiarity in icon design is discussed further in Section \ref{level}. For example, the home menu, restart, settings and exit buttons are shown in Figure \ref{fig:label_icons}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{OtherImages/Icons.png}
    \caption{Game Button Icon Examples}
    \label{fig:label_icons}
\end{figure}

During beta testing, two of the questions asked in the user feedback survey were based on the usability and looks of the UI and HUD. These questions and results are displayed in Figures \ref{fig:label_HUDFeedback} and \ref{fig:label_UIFeedback}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/HUDFeedback.png}
    \caption{User Feedback on HUD}
    \label{fig:label_HUDFeedback}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/UIFeedback.png}
    \caption{User Feedback on UI}
    \label{fig:label_UIFeedback}
\end{figure}
The 'in-level user interface' refers to the HUD. User feedback on its effectiveness varied, with responses ranging from strong agreement to disagreement. However, 5 out of 7 users agreed or strongly agreed that the HUD's information and layout were useful in helping them progress through a level.
When asked for additional feedback, two users mentioned difficulty in finding and getting to the goal in the final level, and suggested adding an on screen arrow to guide the player once the goal is activated. Another user suggested incorporating a mini-map in the bottom right corner of the screen to provide a top-down view of the level, displaying indicators for the goal and animal locations.
Given more development time, implementing a goal pointer arrow would have enhanced the player experience. However, adding animal location markers to a mini-map might have reduced the game's exploration aspect, potentially impacting the intended gameplay experience.
\newline
Feedback on the general UI was very positive, with all users agreeing or strongly agreeing that it was clear and easy to use. One user also noted that the menus complemented the game's style well. Based on these results, no changes were made. However, additional rounds of testing with a larger pool of users would be necessary to fully evaluate the overall effectiveness of the user interface.

\subsection{Music and Sound Effects}

Music and sound effects play an important role in enhancing the player's experience and engagement with the game. They help to create an immersive atmosphere and set the mood of the game. Sound effects also serve as audio feedback for player actions, helping them better understand in-game events. Since Forest Rescue is designed to be a light hearted, casual game, the music needed to reflect this tone. The game features three music tracks: one for the title screen, another for the level select menu, and a third for gameplay. Each track is simple and cheerful, keeping the game's relaxed and happy atmosphere. For the sound effects, I incorporated a variety of sounds for key game events to provide clearer feedback to the player. These include sound effects for UI button presses, combat actions (attacking and taking damage), player movement (jumping, walking, and running), and rescuing animals. 
\newline
In the code, playing sound effects efficiently can be difficult, as they need to be triggered from various scripts without tightly coupling sound management to every individual system. To overcome this, a singleton was implemented, as discussed in Section \ref{singleton}, to create a sound effects manager class that can be accessed from anywhere in the code. This structure is detailed in Figure \ref{fig:label_singletonSoundFX}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/SoundFXSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonSoundFX}
\end{figure}

The SoundFXManager class provides methods for playing both single sound effects and looping sound effects, such as the sound of running which needs to loop over time. In the Unity editor, two audio prefabs were created and assigned to the SoundFXManager via the \_soundFXObject and \_loopingSoundFXObject fields. These prefabs are used to spawn sound effects into the scene. The PlaySoundFX method takes an audio clip, a position to play it at, and a volume level. It then instantiates the \_soundFXObject prefab at the specified location, initializes it with the given audio clip and volume, and automatically destroys it once the clip has finished playing. The PlayLoopingSoundFX method functions slightly differently, as it also takes a string representing a dictionary key. To prevent multiple instances of the same sound from playing simultaneously and causing audio overlap, each looping sound effect is stored in a dictionary using the unique key. When a class needs to stop a looping sound, it calls StopLoopingSoundFX with the corresponding key. The method then checks if the key exists in the dictionary, stops and destroys the associated audio clip, and removes the entry from the dictionary to ensure proper sound management. These two methods are detailed in Figure \ref{loopingsoundfx}.

\begin{figure}[H]
\begin{verbatim}
public void StartLoopingSoundFX(string key, AudioClip audio, 
				Transform spawnPosition, float volume)
{
    // Prevent multiple instances of the same sound
    if (activeLoopingSounds.ContainsKey(key))
    {
        return; 
    }

    AudioSource audioSource = Instantiate(_loopingSoundFXObject, 
					spawnPosition.position, Quaternion.identity);
    audioSource.clip = audio;
    audioSource.volume = volume;
    audioSource.loop = true;
    audioSource.Play();

    activeLoopingSounds[key] = audioSource;
}
\end{verbatim} 
\paragraph{}
\begin{verbatim}
public void StopLoopingSoundFX(string key)
{
    if (activeLoopingSounds.TryGetValue(key, out AudioSource audioSource))
    {
        audioSource.Stop();
        Destroy(audioSource.gameObject);
        activeLoopingSounds.Remove(key);
    }
}
\end{verbatim}
\caption{Start and StopLoopingSoundFX methods from the SoundFXManager class.}
\label{loopingsoundfx}
\end{figure}

Since the SoundFXManager is a singleton, it ensures that only one instance exists throughout the game, preventing duplicate managers and maintaining consistent audio behavior across all scenes. This persistence avoids issues such as duplicated or overlapping sounds when transitioning between scenes. Additionally, being a singleton allows it to be easily accessed from anywhere in the code. Other classes can simply call:
\newline
\texttt{SoundFXManager.Instance.PlaySoundFX();} to concicely play sound effects where needed.

\section{Optimisation}\label{optimisationdev}

Optimisation was a key priority for this game, as the goal was to ensure it runs smoothly on the majority of Windows devices without frame drops. Any performance issues such as lag, would affect the player’s experience, making it difficult to control the player character's movement and combat with precision, which is necessary for this genre of game. The goal was to have the game running at 60 frames per second (FPS) or higher, as this is widely considered the optimal threshold for smooth, responsive gameplay for computers \cite{Samuel2025}. 
\newline
One optimisation technique used in the game was frustum culling, which is explained in more detail in Section \ref{optimisation}. It involves excluding game objects outside of the camera's view frustum (the region visible to the player). By not rendering objects outside this area, the game reduces CPU usage. In Unity, this is handled automatically by the camera, which excludes anything outside the view frustum. The camera also defines near and far clipping planes, where objects beyond the far clipping plane are not rendered, resulting in  a finite rendering area, as shown in Figure \ref{cullingarea}. Occlusion culling was not implemented alongside frustum culling, as it was considered unnecessary for this game. Given that the levels are relatively small and open, there are few objects that would be culled through occlusion, making it less beneficial.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{OtherImages/ClippingPlanes.png}
    \caption{Near and Far clipping planes used by Unity Cameras. \cite{UnityFrustum}.}
    \label{cullingarea}
\end{figure}

Additionally, Level of Detail (LOD) groups were used to optimise the game, as discussed in Section \ref{optimisation}. Unity provides a LOD component that can be assigned to game objects, which determines the distance from the camera at which different levels of detail for an object are displayed. Since the game features a fairly dense environment filled with terrain and nature elements, it was ensured that assets selected for the terrain and nature included multiple LOD models. Once the terrain and nature elements were placed in the scenes, the LOD components allowed for defining distance thresholds that adjust the level of detail, ensuring that objects further from the camera are rendered with less detail, helping to reduce CPU usage.
\newline
Two other optimisations previously discussed include the use of the NavMesh (Discussed in Section \ref{enemy_movement}) for enemy and animal pathfinding, and the object pool design pattern for arrow creation (Discussed in Section \ref{combatsystem}). Baking NavMesh surfaces, which define walkable areas and obstacles to avoid within each level, means that the pathfinding is based on a predefined surface as opposed to real time pathfinding. This approach is more efficient than real time, and works especially well in environments with static terrain. Additionally, the use of the object pool design pattern for arrow spawning is an effective optimisation for managing memory and reducing CPU usage. As discussed in \ref{objectpool}, the object pool pattern minimises memory allocation overhead and prevents memory fragmentation. It also reduces performance bottlenecks caused by frequent garbage collection and avoids expensive object creation. This is particularly beneficial for the arrows shot by enemies, which would otherwise be created and destroyed quickly, potentially impacting performance.
\newline 
Lastly, another optimisation technique used was the implementation of physics layers and the collision matrix. Unity allows the creation of physics layers to categorise game objects and define their interactions. Each layer was configured to interact only where necessary, reducing unnecessary computations. For example, in the combat system, different colliders were assigned separate layers, such as the player, enemy, player weapon, and enemy attack radius. This ensures that interactions are limited to relevant objects. For instance, the archer enemy’s arrows are set to collide only with the player, preventing unnecessary computations with other colliders, such as the player’s weapon, which would otherwise require processing before determining that no interaction is needed. This collision matrix is detailed in Figure \ref{collisionmatrix}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{OtherImages/CollisionMatrix.png}
    \caption{Physics Collision Matrix.}
    \label{collisionmatrix}
\end{figure}

To test whether these optimisations have helped the game run smoothly, this was tested through both the Unity Profiler and beta testing. The Unity Profiler provides real time performance information about your application, giving an overview of resource allocation while developing the application \cite{UnityProfiler}. This was used on the device that was used to develop the game, which is a laptop with an Intel Core i5-12500H (2.50 GHz) processor and 16GB of RAM, running Windows 11. The profiler measured these statistics on a simple playthrough of the game, which involved starting from the title screen, navigating to the first level, and playing it to the end. The results for CPU usage are displayed in Figure \ref{fig:label_CPU}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/CPUusage.png}
    \caption{Unity Profiler graph displaying CPU usage over the course of the game.}
    \label{fig:label_CPU}
\end{figure}

The CPU usage graph displays the game's frame rate over time. While occasional spikes occurred during scene transitions and combat, the frame rate consistently remained below the 60 FPS threshold, often staying well under it. This suggests that the game is capable of running at 60 FPS or higher on this device with ease. 
However, testing on a single device was not sufficient to guarantee smooth performance across different Windows systems. To address this, feedback on performance was included in the user feedback form for beta testing, where users were asked to download and run the game on their own devices and report on its performance. The results of this are detailed in Figure \ref{performancefeedback}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/PerformanceFeedback.png}
    \caption{User Feedback on Game Performance.}
    \label{performancefeedback}
\end{figure}

Seven users downloaded and tested the game on various Windows devices, including both PCs and laptops. All users either agreed or strongly agreed that the game ran smoothly on their systems. This feedback suggests that the game performs very well across different Windows devices. However, to fully assess its performance, further testing would be needed, particularly to determine the minimum hardware requirements for running the game at a playable standard.

\section{Testing}\label{testing}

To ensure the game was both functional and user friendly, a range of testing methods were employed throughout development to evaluate usability, stability, and performance. Game development typically involves numerous testing strategies as part of both quality assurance (QA) and user experience (UX) design. Unity’s documentation outlines several key approaches, including unit testing, integration testing, regression testing, functional testing, performance testing, and beta testing \cite{UnityTesting}. For this project, the most relevant and feasible methods that were applied are unit testing, playtesting, beta testing, and performance testing. 
These selected methods provided coverage across usability, functionality, and performance, giving a well-rounded evaluation of the game's quality within the time constraints of the project development.\newline

Unit testing is a technique that involves testing individual components of the game code. This helps make sure bugs are caught early on and that any changes to the code do not break existing functionality \cite{UnityTesting}. Automated unit testing was carried out using the Unity Test Framework (UTF), which extends the C\# test framework NUnit. The UTF allows tests to be run in both Edit Mode and Play Mode \cite{UnityUTF}. Edit Mode tests are typically used for isolated units of code that do not rely on the game being actively running. In contrast, Play Mode tests are for code that interacts with the game environment, such as components that must be attached to GameObjects or systems that require runtime behaviour, making them more appropriate for integration testing. Some core components of the code, such as the LevelManager state machine states, the base ObjectPool class, and the SoundFXManager, were tested using a combination of edit mode and play mode unit tests. However, the scope of testing was limited due to the runtime behaviours of most other classes. Features like collisions, animation transitions, and input handling are tightly coupled with Unity’s runtime environment, making them difficult to test in isolation without extensive mocking. As a result, only standalone logic components were covered by unit tests during the project timeline. Testing these components still provided assurance that key systems continued working as new code was added.\newline

Playtesting focuses on evaluating core game mechanics during development, offering feedback on balance and difficulty, while also being used to find bugs \cite{flashjungle_2022}. In this project, playtesting was conducted informally at multiple stages by asking users to try early versions of the game and provide feedback. This process was especially valuable in refining user interface components, player movement, and combat mechanics. For example, feedback helped improve the layout and clarity of HUD elements (Discussed in  Section \ref{UIDesign}), informed adjustments to enemy difficulty balancing (Discussed in Section \ref{leveldesign}), and influenced key combat system decisions, such as implementing a temporary stunned effect on enemies after being hit, which improved the overall combat and fairness. \newline

Beta testing is similar in principle to playtesting but is conducted more formally, using a nearly complete version of the game. It involves a larger group of testers and aims to identify final bugs, gather user feedback on the overall experience, and make last minute adjustments prior to release \cite{flashjungle_2022}. This process involves distributing a beta version of the game, accompanied by structured bug report and user feedback forms for testers to complete after playing. For this project, beta testing began in Week 8 of Term 2, immediately after the final planned feature (sound effects) was implemented. This timing allowed for a two week window to collect user feedback and apply improvements before the end of term. A formal user feedback form was distributed and completed by seven users, compared to the smaller group of two who participated in earlier playtesting. While an ideal beta test would involve a significantly larger user base to ensure a broader range of feedback, constraints around finding players and time made this challenging. A separate bug report form was also provided and completed by testers who encountered bugs in their playtime. The feedback collected through the user feedback form is analysed and discussed in the User Experience Development Section (\ref{UX}). A typical bug report form includes a summary of the issue, the platform on which it occurred, and clear steps to reproduce the bug. During this phase, two users identified previously unknown bugs. These included objects in the level terrain missing colliders, and an issue where the player could collide with cages, but enemies could not. These bugs were reviewed and fixed based on the feedback provided through the submitted forms. Overall, the beta testing phase provided the most comprehensive feedback throughout development, enabling the refinement of multiple features and ensuring there were not any major bugs in the game. \newline

Lastly, performance testing was carried out, which involves testing the game to ensure that it runs smoothly and efficiently on different hardware and software configurations \cite{UnityTesting}. This was done using the unity profiler tool, along with beta testing. The method and results of this were discussed further in the Optimisation Development Section \ref{optimisationdev}.  

%%%%%%%%%%%%%%%%%%%%%%
%%% Reflection and Evaluation
\chapter{Reflection and Evaluation}\label{reflection}

This chapter reflects on the development of the project, evaluating whether its objectives were successfully achieved and identifying areas for potential improvement. 
\newline
Overall, the project progressed well in terms of time and meeting its objectives. All of the original goals outlined in Section \ref{objectives} were successfully completed by the planned deadline, which was week ten of term two. However, some individual tasks exceeded their estimated timeframes, including the implementation of the player movement system and the third enemy type. This was primarily due to the extra time required to refactor these systems using the hierarchical state machine and object pooling design patterns.
While these refactors extended development time, they improved the modularity and maintainability of the game code, which was important as the game scaled in complexity. This suggests that the initial time estimates did not properly account for the time taken to refactor the core systems. In future projects, more buffer time would be allocated to account for improvements like these, particularly when refactoring multiple areas of the code.
\newline
Additionally, while there was time for some playtesting and one structured round of beta testing, fully testing and refining the game for release would have required multiple rounds of beta testing with a larger group of users. In future project timelines, this would need to be accounted for to produce a more polished game for release. \newline

During the beta testing phase, users identified several improvements that could have improved the user experience. Two of these included implementing a goal indicator system to help with level navigation and introducing a new weapon type for the player, such as a bow and arrow. These additions would have required new gameplay systems, rather than simple refinements of existing features. Therefore, given the scope and time constraints of the project, it was not feasible to implement these features without risking the overall quality of the core game.
As a result, incorporating formal user feedback earlier in the design process may have helped identify more features to enhance the user experience, allowing them to be implemented earlier in development. \newline

When planning the original timeline and features for the game, the focus was on developing a minimum viable product that demonstrated all the core components of a complete game, including player mechanics, combat systems, level and UI/UX design. This decision allowed for exposure to the full game development process while ensuring the project could be completed within the given timeframe. However, this approach required limiting the complexity of certain systems, for example, movement mechanics were kept simple, excluding features such as crouching or advanced combat actions. While this helped limit the scope of the project, it also meant sacrificing opportunities to improve gameplay variety and player engagement. With a larger timeframe, features such as alternate combat styles, additional themed levels, a tutorial level and saving score data could have been implemented to improve the player experience. In future projects, implementing more complex features would be prioritised early in the development process, with a larger project timeframe to accommodate their implementation alongside multiple rounds of user testing. \newline

If this project were to be restarted, more time would be allocated at the beginning for thorough planning of the code structure and game features. This would include creating full design documents and initial UML diagrams to map out the game requirements and how core systems interact, rather than building the architecture from scratch and refactoring later. A structured approach from the beginning would have supported faster development of maintainable code and provided clearer direction for implementation.\newline
In terms of testing, it would have been beneficial to incorporate integration testing alongside unit testing. However, implementing integration tests in Unity would have required additional time to learn new tools on top of learning the Unity engine itself. Given the project's timeframe and the learning curve that was presented, this was not feasible. However, for a production level project, integration testing is essential to ensure a polished game and would be prioritised in future work.

%%%%%%%%%%%%%%%%%%%%%%
%%% Professional Issues
\chapter{Professional Issues}
Game development involves various professional and ethical considerations, particularly in legal compliance and asset usage when publishing a game commercially. Throughout this project, I have had to consider licensing restrictions when using third party assets and the legal requirements of publishing a game using Unity engine. This Section discusses these issues and how they should be addressed professionally if this project were to be published. \newline

The majority of assets used in the game were sourced from the Unity Asset Store, which provides a large variety of assets that you can download and use in Unity Engine. Most assets from the Unity Asset Store are royalty-free on purchase or free download, except for ones labeled as 'restricted', which cannot be used commercially. Any restrictions are detailed in the description of the asset in the store \cite{UnityCommercial}. However, it is important to ensure the correct license type is purchased when downloading an asset for commercial use.
All Unity assets fall under either Extension, Single Entity, or Multi Entity licence types. Extension assets cover any assets found under the 'tools' category in the store, and users are required to purchase one seat per user that has access to the raw asset files \cite{UnityLicences}. Single Entity and Multi Entity assets can be any other type of asset that does not fall under the 'tools' category. Single Entity assets are typically for single users or companies, and permits use by all team members within a single company. Multi Entity assets cover parent, child and sister companies, as well as contractors on a project, allowing them access to the raw asset files across different branches of an organisation \cite{UnityLicences}. Currently, all assets used in the game fall under either the Extension or Single Entity license types. As the only developer working on the game, I am a single entity, meaning these assets can be used royalty-free if the game was published commercially, and any Multi Entity licences would not need to be purchased. Failing to purchase the correct asset licenses can lead to a game being removed from distribution platforms and may result in legal disputes.

When publishing a game commercially using Unity engine, it is important to determine whether a paid Unity license is required and what tier is appropriate. Unity offers several licensing plans, with the main options being Unity Personal, Pro, Enterprise, and Industry. Unity Personal is free and intended for individual developers, while the paid tiers are designed for businesses and larger organisations.
Games can be published commercially using any of these plans, including Unity Personal. However, whether an upgrade to a paid license is required depends on 'total finances', which Unity defines based on revenue and funding. If a developer is providing services to a third party, total finances are measured by the client’s total revenue and funding, regardless of the source. If the developer is not providing services to a third party, total finances are determined by the total revenue and funding generated through the use of Unity. For governmental, non-profit, educational, or academic institutions, total finances are based on the entity’s entire budget \cite{UnityTC}.
Each licensing tier has a maximum limit on total finances for eligibility. If this limit is exceeded, the user will have to upgrade to the tier that they are eligible for to continue using Unity engine. For this project, the game was developed using Unity Personal, which allows for the game to be published commercially. However, if my total finances were to exceed the \$200,000 USD threshold, upgrading to a Unity Pro license would be required. Using the wrong Unity license would violate Unity's terms of service and could result in restrictions on both the use of the engine and the distribution of games created with it.\newline

Awareness of licensing types and Unity’s publishing terms influenced asset selection during development. For instance, I ensured that all downloaded assets had commercial use rights, which occasionally limited the assets to select from but guaranteed compliance if the game were to be released.


%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}
\section{Code Style}
Below is the code style used, following Unity's guidelines \cite{unity_2022_codestyle}.
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Aspect}              & \textbf{Chosen Convention}                                                                                   \\ \hline
\textbf{Field Naming}        & Private fields use camelCase with a leading underscore (e.g., \texttt{\_health}, \texttt{\_animator}). Public fields use PascalCase. \\ \hline
\textbf{Property Naming}     & Public properties use PascalCase (e.g., \texttt{Health}, \texttt{MaxHealthReadOnly}).                         \\ \hline
\textbf{Interface Naming}    & Interface names start with "I" and describe behavior (e.g., \texttt{IDamageable}, \texttt{IHealthSubject}).   \\ \hline
\textbf{Event Naming}        & Events are named with verb phrases and often follow "OnEventName" format (e.g., \texttt{DoorOpened}).         \\ \hline
\textbf{Method Naming}       & Methods use  PascalCase (e.g., \texttt{TakeDamage}, \texttt{AddHealth}).                    \\ \hline
\textbf{Braces Style}        & Always include braces even for single-line conditional statements (e.g., \texttt{if (condition) \{ DoSomething(); \}}). \\ \hline
\textbf{Files per Class}     & Each class resides in its own file, and file names match MonoBehaviour class names (e.g., \texttt{PlayerHealthAndDamage.cs}). \\ \hline
\end{tabular}
\caption{Code Style Conventions Followed in the Project}
\label{tab:codestyle}
\end{table}

\section{Development Diary}
\textbf{Week 12}\newline
08/04/2025
\newline- Finished off unit tests for selected files, and fixed error caused by merge of branches which made Unity unable to find ScoreManager script.

\textbf{Week 9}\newline
19/03/2025
\newline- Set up test assemblies for unit testing and wrote unit tests for the level manager state machine.

\textbf{Week 8}\newline
16/03/2025 - Objective Complete : Playable Builds
\newline- Created first builds of the game for Windows and Mac, and distributed them for beta testing.\newline
14/03/2025
\newline- Bug fixes to all current known bugs, including scores being incorrect past the first level, player jump animation desync, and adding missing terrain colliders.\newline
13/03/2025
\newline- Tidied up code files to remove redundant code and made sure XML documentation has been added to all files.
\newline- Removed observer pattern from animal rescue logic because it was overcomplicated for the scenario (only one observer).\newline
12/03/2025 - Objective Complete : Music and Sound Effects
\newline- Added all remaining sound effects to the game.
\newline- Bugfix to LevelCleared and GameOver scripts not changing the level state back to play mode once disabled which caused title screen movement to stop.\newline
11/03/2025
\newline- Finished adding player sound effects
\newline- Changed sound settings menu script to save user preferences.\newline
10/03/2025
\newline- Created SoundFXManager script to easily play sound effects from within the code.
\newline- Created SoundMixerManager script along with a sound settings menu to enable volume to be controlled with an audio mixer.
\newline- Added background music for all scenes.
\newline- Began adding sound effects for player.

\textbf{Week 7}\newline
07/03/2025
\newline- Fixed bug that was causing game to crash when playing a level a second time.\newline
06/03/2025
\newline- Started balancing enemy stats for difficulty.
\newline- Changed archer enemy to stay standing in place.\newline
05/03/2025 - Objective Complete : Three Levels
\newline- Created new levels: level one and two.
\newline- Changed the original level to be level three so that level one and two are easier and more introductory for beginners.
\newline- Linked all relevant UI buttons to new level scenes.

\textbf{Week 6}\newline
27/02/2025 - Objective Complete : Full User Interface
\newline- Created the level select menu scene.
\newline- Linked all scenes together (TitleScreen, LevelSelect, LevelOne) through button presses.
\newline- Created scene transition animations and a SceneLoader script to enable them when buttons are pressed.\newline
26/02/2025
\newline- Added all UI elements to title screen (non functional).
\newline- Created a movement script to move and animate the player and enemies in a circle.\newline
25/02/2025
\newline- Created a scene for the game title screen.

\textbf{Week 5}\newline
20/02/2025 - Objective Complete : Three Enemy Types
\newline- Configured the archer goblin movement.
\newline- Synced arrow's position and shot timing with the position of the enemy and attack animation.

\textbf{Week 4}\newline
13/02/2025
\newline- Created an arrow prefab and configured the enemy to shoot them with object pooling.\newline
12/02/2025
\newline- Began prototyping the archer goblin.
\newline- Removed redundant functionality for basic enemy attack script.
\newline- Created a new animator for archer goblin.

\textbf{Week 3}\newline
08/02/2025 - Objective Complete : Level Completion and Scoring System
\newline- Implemented a score system which shows a final score for the player on the Level Cleared screen.\newline
07/02/2025
\newline- Created a pause button and pause menu for the level.
\newline- Created an in game timer element for the HUD.\newline
06/02/2025
\newline- Redesigned the current UI elements with new UI assets.
\newline- Updated Game Over, Level Cleared screens and the Player's Health Bar.\newline
04/02/2025
\newline- Began refactoring scripts to use a LevelManager which controls the states of the level. (Playing, GameOver etc)

\textbf{Week 2}\newline
31/01/2025
\newline- Created a collider to detect the player entering the goal area.
\newline- Configured the goal scripts to activate the level cleared UI screen on collision.
\newline- Created a goal indicator arrow to direct the player towards the goal after rescuing all the animals.\newline
30/01/2025
\newline- Redesign of quest UI based on user feedback.\newline
29/01/2025
\newline- Refactored animal script to use observer pattern.
\newline- Created UI elements for questlines and created basic show and hide animations for them.
\newline- Configured the quest animations and UI to show based on whether the animals are rescued or not.

\textbf{Week 1 - Start of Term 2}\newline
24/01/2025
\newline- Improved the enemy combat mechanics based on user feedback by disabling enemies from being able to attack while stunned.
\newline- Bugfix to prevent enemies from attacking during their death animation.\newline
23/01/2025
\newline- Created teleport mechanic for when animals get stuck too far away from the player.
\newline- Set up new physics layers for the animals and teleport radius and configured them in the collision matrix.\newline
22/01/2025
\newline- Began working on animal follow mechanic (Animal follows the player once rescued from its cage).
\newline- Created Animal script to manage the movement and set it up with basic following.


\textbf{Week 11 - End Of Term 1}\newline
06/12/2024
\newline- Bugfix to player's NavMeshAgent which was causing the agent to not relocate to the player when they leave the NavMeshSurface.
\newline- Bugfix to the heart idle animation which was overriding the positions of all hearts in the scene.
\newline- Finalised level one layout
\newline04/12/2024
\newline- Refactored the UI system to use the observer pattern.
\newline03/12/2024
\newline- Added collectible hearts which increase the player's health.
\newline02/12/2024
\newline Redesigned layout and environment for level one.

\textbf{Week 10}\newline
27/11/2024
\newline- Created a second melee enemy which is faster and does less damage.
\newline25/11/2024
\newline- Created the HUD (Heads Up Display) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024 - Objective Complete : Combat System
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters its follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024 - Objective Complete : Player Movement System
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured its movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage

\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{OtherImages/FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name2}
\end{figure}
The Assets folder contains all of the work completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram highlights the most important subfolders, such as the scripts folders, where all the C\# scripts are organised. Note that not all folders are included in the diagram. \newline

Files Relevant to the Player State Machine (Assets/Fighter/Scripts):
\begin{itemize}
    \item \texttt{ PlayerBaseState.cs, PlayerRunState,cs, PlayerJumpState.cs, PlayerStateMachine.cs, PlayerStateFactory.cs} (There are other state files within this folder, Jump and Run are just two examples)
\end{itemize}

Files relevant to the combat system:
\begin{itemize}
    \item \texttt{IDamageable.cs} (Assets/Interfaces)
    \item \texttt{PlayerHealthAndDamage.cs, WeaponManager.cs, WeaponAttributes.cs} (Assets/Fighter/Scripts)
    \item \texttt{Enemy.cs, AttackRadius.cs, RangedAttackRadius.cs, ObjectPool.cs, PoolableObject.cs, Arrow.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to enemy movement:
\begin{itemize}
    \item \texttt{Enemy.cs, FollowRadius.cs, EnemyMovement.cs, EnemyScriptableObject.cs,}\newline  \texttt{RangedEnemyMovement.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to the health UI system:
\begin{itemize}
    \item \texttt{IHealthSubject, IHealthObserver} (Assets/Interfaces)
    \item \texttt{PlayerHealthBar.cs, EnemyHealthBar.cs, GameOver.cs} (Assets/UI/Scripts)
\end{itemize}
Files relevant to animal rescue:
\begin{itemize}
    \item \texttt{Cage.cs} (Assets/CuteRaccoons/Scripts)
    \item \texttt{Animal.cs, AnimalTeleportRadius.cs} (Assets/Interfaces)
\end{itemize}

Files relevant to the level progression and score system:
\begin{itemize}
    \item \texttt{UIQuestManager.cs} (Assets/CuteRaccoons/Scripts)
    \item \texttt{LevelManager.cs, LevelState.cs} (Assets/Managers)
    \item \texttt{GoalRadius.cs, LevelCleared.cs, GameTimer.cs, ScoreManager.cs, SceneLoader.cs} (Assets/UI/Scripts)
\end{itemize}

Files relevant to sound system:
\begin{itemize}
    \item \texttt{SoundFXManager.cs, SoundMixerManager.cs} (Assets/Managers)
\end{itemize}

\section{Demo Video Link}
\url{https://youtu.be/4mPIEk5YFJI}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\phantomsection
\addcontentsline{toc}{section}{Bibliography}
\bibliographystyle{plain}
\raggedright
\bibliography{references}


\newpage
\phantomsection
\addcontentsline{toc}{section}{Assets Used}
\renewcommand{\bibname}{Assets Used}
\begin{thebibliography}{99}

\bibitem[41]{skybox} Key Mouse. Customizable Skybox. Available at: \url{https://assetstore.unity.com/packages/2d/textures-materials/sky/customizable-skybox-174576}

\bibitem[42]{forest_textures} Proxy Games. Stylized Nature Kit Lite. Available at: \url{https://assetstore.unity.com/packages/3d/environments/stylized-nature-kit-lite-176906}. 

\bibitem[43]{VFX} Lana Studio. Hyper Casual FX. Available at: \url{https://assetstore.unity.com/packages/vfx/particles/hyper-casual-fx-200333}.

\bibitem[44]{player} SEMA Game Studio. Modular Cute Fantasy Character Pack \#1. Available at: \url{https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/modular-cute-fantasy-character-pack-1-293865}

\bibitem[45]{sound_effects} SURIYUN. Monsters Forest Pack 2. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/monsters-forest-pack-2-251936}. 

\bibitem[46]{sound_effects} Meshtint Studio. Forest Ruins Pack Cute Series. Available at: \url{https://assetstore.unity.com/packages/3d/environments/fantasy/forest-ruins-pack-cute-series-182412}. 

\bibitem[47]{sound_effects} Lost Panda Games. Low Poly Cartoon Item Pack - 3D. Available at: \url{https://assetstore.unity.com/packages/3d/props/low-poly-cartoon-item-pack-3d-274991}. 

\bibitem[48]{sound_effects} SURIYUN. Cute Goblin. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/cute-goblin-225492}. 

\bibitem[49]{sound_effects} Monsieur Fred. Adventure/Exploration Music Pack. Available at: \url{https://assetstore.unity.com/packages/audio/music/adventure-exploration-music-pack-196816}. 

\bibitem[50]{sound_effects} B.G.M. Casual Game BGM \#5. Available at: \url{https://assetstore.unity.com/packages/audio/music/casual-game-bgm-5-135943}. 

\bibitem[51]{sound_effects} Dustyroom. FREE Casual Game SFX  Pack. Available at: \url{https://assetstore.unity.com/packages/audio/sound-fx/free-casual-game-sfx-pack-54116}. 


\bibitem[52]{sound_effects} Layer Lab. GUI - Yellow Kid. Available at: \url{https://assetstore.unity.com/packages/2d/gui/gui-yellow-kid-177697}. 

\end{thebibliography}

\label{endpage}

\end{document}

\end{article}
