\documentclass[]{final_report}
\usepackage{graphicx}
\usepackage{xcolor} 
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{forest}
\usepackage{cite}
\usepackage{float}
\usepackage{url}
\usepackage[breaklinks=true]{hyperref}
\usepackage{breakurl}
\usepackage{subcaption}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Final Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 5800

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 13/12/2024

\vskip3em

Signature: Romina Petrozzi

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
This report details the development of a 3D platformer game created using Unity, exploring concepts in game design and software engineering. The game features a fantasy forest world where the player controls a hero tasked with rescuing animals while battling goblin enemies. The report provides an overview of game engines, design patterns for video game development, and user experience considerations. It details the development process so far, including justifications for key design decisions. Additionally, the report focusses on the application of software engineering principles, such as design patterns, testing methodologies, and adherence to a consistent code style. A timeline is also included, detailing the features achieved so far and the adjustments made to the original plan.
\end{abstract}
\newpage
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
The video game industry has grown into one of the largest sectors in the entertainment industry, with video game sales being about five times higher than global music revenues, higher than consumer book sales, and similar to movie revenues \cite{marchand2013value}. This growth has been driven by many factors, including the growth of software, improvement of internet technology, and innovation \cite{zackariasson2012video} . Video games have evolved significantly over the years, progressing from simple 2D graphics to immersive 3D experiences, and with the oncoming development of virtual reality (VR) and artificial intelligence (AI) technology, they are set to become even more immersive and engaging. Creating video games is a very complex process involving many interconnected systems such as gameplay mechanics, graphics, AI, sound, animation and gameplay design. \newline

My motivation for this project stems from my interest in the VR industry. By working on this game with Unity 3D, I will gain experience using one of the most widely used engines for VR development and practice working with 3D environments. These skills will transition well into VR development, providing a good foundation for future projects in that field. Additionally, I am aiming to improve my software engineering skills, as creating large games requires solid software engineering principles. To keep up with evolving requirements and user expectations, it is important that the code stays maintainable, efficient and scalable.\newline

The genre of game being developed is a mix between 3D platformers and action-adventure games. It is set in a fantasy forest, where the player controls an axe-wielding hero tasked with rescuing trapped animals guarded by goblin enemies. There will be a set number of levels, each with increasing difficulty that the player must traverse through. They will explore each level to find and rescue each animal, with simple platforming and obstacles. Once each animal is rescued, they will follow the player around until they take them to the goal point. Points are awarded based on the number of enemies defeated in a level, and to clear each level the player must rescue all the animals being guarded by returning them to the goal. In addition, there will be extra collectibles hidden throughout the levels which will grant the player bonus health and temporary power ups. This level design aims to cater to both ``segments of players labelled as `experiencers' versus `achievers''' \cite{zhao2022dynamic} by offering contained, linear levels which also encourage exploration. A highly successful example of this design is Super Mario 3D World, which my level designs will take some inspiration from.\newline

\color{red} For the development of this game, the Unity game engine stood out as the best choice\color{black}, which provides the necessary tools and functions for 3D environments, assets and physics required for the game. Several other game engines were compared that offer 3D capabilities, such as Unreal Engine, Unity and Godot. These engines vary in features, ease of use, and capabilities, and Unity was the best fit for the game's requirements. To ensure maintainable and scalable code for the project, common design patterns for game development were researched and incorporated, such as State Machines and Object Pools which promote extendable and reusable code. Additionally, a large focus of the project was making decisions to \color{red} create a good user experience by setting up user friendly controls, user interface, camera movement and level design. \color{black}
\section{Objectives}
My main objectives for the project include:
\begin{itemize}
    \item Player Movement System
    \begin{itemize}
	\item{Create smooth movement mechanics including walking, running and jumping with proper animation blending.}
    \end{itemize}
    \item Combat System
    \begin{itemize}
	\item{Implement a basic combat system for player-enemy interactions including damage mechanics and animations for attacks, hits and deaths.}
    \end{itemize}
    \item Full User Interface
    \begin{itemize}
	\item{Implement a menu system with level selection, and a full heads up display during levels.}
    \end{itemize}
    \item Three Enemy Types
    \begin{itemize}
	\item{Create at least three types of enemies that have some variation in attack behaviours.}
    \end{itemize}
    \item Level Completion and Scoring system
    \begin{itemize}
	\item{Create scoring system based on defeated enemies, and implement end of level mechanic.}
    \end{itemize}
    \item Three Levels
    \begin{itemize}
	\item{Design three unique level layouts, increasing in difficulty.}
    \end{itemize}
    \item Testing and Optimisation
    \begin{itemize}
	\item{Playtest the game with a few users to find and fix bugs, and optimise performance for smoother gameplay.}
    \end{itemize}
    \item Design Patterns
    \begin{itemize}
	\item{Refactor code into common design patterns where appropriate.}
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
Game development is a multidisciplinary process that includes areas such as creating a game concept, designing its mechanics, and creating an engaging user interface and experience. Each of these elements are equally important to create a game that is accessible, enjoyable, and polished. \color{red}This section covers the research that was carried out for the game, discussing the different approaches explored for various aspects of development. \color{black}


\section{Game Engines}
Game engines are platforms that make it easier to create computer games. They allow you to integrate and combine into single unit individual game elements such as animations, interaction with the user, or detection of collisions between objects \cite{Barczak2019}. These engines provide reusable components, allowing developers to focus on gameplay and design rather than redeveloping fundamental systems. There are many engines available, each suited to different types of projects. Popular engines for both 3D and 2D game development include Unreal Engine, Unity and Godot, while GameMaker and Construct are popular for 2D development. \color{red}As this project is focused on 3D game development, my primary research concentrated on those engines.\color{black}
\newline
Unreal Engine focuses on providing high-quality games with outstanding graphics and realism, thanks to its powerful graphics and rendering capabilities. Its Blueprint visual scripting system is a distinctive characteristic which allows programmers to build gameplay mechanics and events without writing any code. However Unreal Engine also provides the option to use C++ for more advanced customisation \cite{eventyr_2023}. While this engine offers many benefits, it comes with a very steep learning curve, as the interface and functionalities are intricate. Another drawback is that the software is resource intensive, requiring a more demanding system configuration for both gameplay and development \cite{eventyr_2023}. 
\newline
Unity is a powerful engine that is used by both small and large development studios. Its most prominent features are its user friendly interface, cross-platform compatibility, and powerful rendering and performance. It also provides a large asset library and extensive documentation. While Unity provides great performance and graphics, it is not an ideal choice for massive open worlds or intricate graphics as its performance is limited compared to that of Unreal Engine which is more suited to this type of game \cite{medium_2024}. Additionally, while Unity has a large user community and documentation, it can present a steep learning curve for those new to game development or programming, as it primarily uses C\# for scripting.
\newline
Godot is a versatile open-source game engine that offers 3D and 2D development. It offers a lightweight, user friendly interface and provides its own scripting language, GDScript which is beginner friendly. Godot also requires less power and expense to run in comparison to Unity and Unreal Engine. Some drawbacks of this engine are having a less extensive documentation and asset library in comparison to Unity and Unreal Engine, and is less suited to games that require a large range of functionality. \cite{hatton_2024}. \newline
For this game, my requirements include good tools and support for 3D development, an interface that is relatively beginner-friendly, and access to a large asset library, as I will not be creating the 3D models from scratch. Since I have chosen a stylised visual style for the game, which gives a more cartoon-like look over realism, the project does not require an engine with advanced high-end graphics capabilities. Additionally, the decision to create contained levels instead of a large open-world environment means that the engine does not need to support expansive or highly complex environments.
Unity stands out as the best fit for these requirements due to its powerful 3D development capabilities, while being less resource intensive than Unreal Engine. Additionally, it is the most vastly documented engine of the three with a large asset store making it very accessible to learn and use.


\section{Design Patterns}
As programs get larger, it is critical to write code in such a way that classes and modules can communicate with each other in an intelligent way \cite{Doran2017}. In the context of game development, the complexity of the code can become large very fast, making it important to ensure that the code is clean, reusable, and scalable. Design patterns provide solutions to common design problems, enabling code to be easily extended and reused. It is important to create reusable components to reduce the amount of code that needs to be written for the game, and additionally design patterns make code easily extendable by designing it in such a way that adding new functionality does not require many changes to the existing functionality. There are many patterns that are widely used across many types of games\color{red}, and this section will discuss the most relevant patterns to this genre of game. \color{black}


\subsection{State Machines}\label{HSM}
\color{red} State machines are a widely used design pattern in game development for managing objects that transition between predefined states. For example, a player character may switch between idle, walking, and running states based on user input. There are different variations of the state machine pattern, each addressing different levels of complexity in state transitions. These include the Finite State Machine (FSM), Concurrent State Machine (CSM), and Hierarchical State Machine (HSM). The FSM is the simplest of the three, ensuring that an object can transition between states while preventing multiple states from running simultaneously. \color{black} This pattern solves two problems: an object should change it’s behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states \cite{unity2022_patterns}. \color{red} This pattern works by defining an enum to represent a set of possible states such as walking, idle, or running, along with a state switching method that transitions between them based on specific conditions. This method determines which behavior should be executed in each state. FSMs work well for managing a simple set of states that do not overlap or interfere with one another. However, it can become complicated when additional mechanics introduce their own state dependent behaviors that overlap with the current states. For example, if a player character needs to use a weapon that has its own states: idle, attacking, or reloading, adding these into the existing FSM would double the number of states, as each movement state (idle, walking, running) would need a second version that accounts for weapon handling \cite{nystrom2011game}. \newline
This issue is addressed by the Concurrent State Machine pattern. Instead of combining movement and weapon mechanics into a single FSM, a CSM allows multiple state machines to run independently. In this case, the player character would keep references to two separate state machines, one for movement states and another for weapon states that run concurrently. This allows states from both machines to overlap while keeping each set of states independent.
The Hierarchical State Machine (HSM) builds on the FSM by introducing a hierarchy of states, enabling shared behaviors across multiple states. This is especially useful when multiple states share common functionality. For example, all movement states that keep the player grounded need to apply gravity calculations. Instead of duplicating this logic in each movement state, it can be placed in a superstate which runs alongside its substates. In this case, the superstate would handle gravity calculations for the player, while the substates manage specific movement behaviors. 
\newline
The State pattern can be used to implement state machines as opposed to using enums to represent each state. This approach defines a base state class that all individual states inherit from, encapsulating state specific behavior into dedicated classes. This makes the system more scalable for more complex and numerous states, as each state manages its own logic without relying on a large switch statement. 
\color{black} 


\subsection{Observer}\label{observer}
\color{red}
The Observer Pattern is a behavioral design pattern used to manage communication between objects in a way that allows one object (the subject) to notify multiple other objects (the observers) when its state changes. This pattern is particularly useful in games where multiple objects need to react to specific events, such as changes in the player’s health, score, or game state. In the pattern there are two main components: the subject and the observers. The subject is the object that holds the state or data, which may change over time. When an event occurs, the subject notifies all registered observers. The observers on the other hand, listen for the event changes and define the actions they need to take when notified \cite{nystrom2011game}.
\newline
An example of its use in games would be a quest system where the quest progress is the subject, and several observers such as the quest tracker, the reward system, and quest related UI elements are notified whenever the player's progress on a quest changes. When the player completes an objective within the quest, the subject (the quest class) will notify the observers (quest tracker, reward system, UI elements), which then update themselves accordingly. This ensures that all components related to the quest are synchronized without the need for the subject to directly reference each observer.
\newline
The main benefit of using the Observer Pattern in game development is that it decouples the components of the game. The subject doesn’t need to know what each observer does, only that it needs to notify them when an event occurs. This means that the subject can focus on its core functionality, while the observers can be independent. Additionally, if new observers need to be added or existing ones modified, this can be done without changing the subject class, making the system more extendable and easier to maintain.
\newline
The Observer Pattern is also helpful in event driven systems. Games are often full of events, such as when a player picks up an item, takes damage, or completes a level. Instead of having the subject manage the responses for all these events, the Observer Pattern allows different parts of the game such as the UI, sound systems, or gameplay mechanics, to listen for and respond to the relevant events. This improves the scalability of the game’s architecture as more components are added.
\color{black}

\subsection{Strategy}\label{strategy}
\color{black}The Strategy pattern is a design pattern used to define a family of behaviors and allows them to be interchangeable. \color{red} In game development, this pattern is often used to handle different behaviors that an object can perform, such as various movement styles for enemies, different attack strategies for characters, or different types of player abilities. The way this pattern works is by defining a set of behaviors in separate classes, and let the client class decide which behavior to use at runtime.
\newline
In an implementation of this pattern, the client class (like an enemy or player character) holds a reference to a strategy interface and uses it to perform a specific action, such as moving or attacking. The actual behavior is defined in separate strategy classes, each of which implements the strategy interface. This means that the client class doesn't need to know the details of the behavior, it just delegates the task to the strategy it has been assigned. This is especially useful in situations where an object may need to switch between different behaviors based on certain conditions during gameplay \cite{Doran2017}.
\newline
For example, an enemy character in a game may have different attack strategies, one for melee combat and another for ranged combat. By using the Strategy pattern, the enemy class doesn’t have to contain logic for both melee and ranged attacks. Instead, the enemy can switch between attack strategies by dynamically assigning a different strategy object, based on whether the player is close enough for a melee attack or far away for a ranged attack. This decouples the behavior logic from the enemy class, making it easier to maintain and extend. This approach also allows for more flexibility and extendability in the game's code. New behaviors can be added without modifying the existing class, and changes to existing behaviors only need to be made in the relevant strategy classes. 


\color{black}









\subsection{ObjectPool}\label{objectpool}

\subsection{Singleton}\label{singleton}

\section{Game Mechanics}
- Discuss different combat mechanics / ways of doing it i could have done \& same for player movement maybe.

\section{Optimisation Techniques}
\color{red}
Optimisation techniques are crucial in game development, as performance lag can significantly impact the player's gameplay experience in many game genres. In particular, 3D platformers require precise movement and jumps for navigating levels and obstacles, and experiencing frame drops can make the gameplay frustrating for the player. Some of the main optimisation techniques used for games are level of detail (LOD) management, occlusion culling and frustum culling. \newline
Occlusion Culling ‘is the mechanism by which Unity avoids rendering computations for GameObjects that are fully hidden from view by other GameObjects’ \cite{Singh2022}. This means that if an object is within the camera's view but fully blocked by another object, it will not be rendered. By doing this, performance is significantly improved as resources are not wasted on elements outside of the player's immediate view. This technique is most beneficial in 3D games with large open world environments, indoor navigation, and densely structured shooter maps, where many objects may be hidden from view at any given time.
----------------------------------------------- ADD FRUSTUM CULLING ---------------------------------------------------------
LOD management is an optimization technique that dynamically adjusts the complexity of an object's geometry based on its distance from the camera. In Unity, this is done by using LOD levels, which specify amount of detail of an object’s geometry to be rendered based on the object’s distance from the camera \cite{Unity2024LOD}. When an object is far from the player, a lower-detail version with fewer polygons is rendered, whereas a higher-detail version is used when the object is closer. This approach decreases the GPU's workload, freeing up resources for closer objects. This technique is particularly useful in expansive 3D environments, such as open-world games or any game featuring a vast, open map \cite{IndieGamesDevel}.
\color{black}

\section{User Experience}\label{userexperience}
Creating an engaging and intuitive user interface (UI) and user experience (UX) is important in modern game development. 
UX in games includes the player's overall interaction with the game, including controls, interface design, camera systems, feedback mechanisms, and navigation flows \cite{Kramarzewski2023}. It focuses on ensuring that the game is enjoyable, accessible, and meets player expectations. 
\newline Designing effective input involves adhering to the principles of ergonomics and user expectations. Ergonomics refers to creating controls that are natural for hand movement, while user expectations involve using input controls that are familiar, so players can quickly learn the controls \cite{Rogers2014}. For example, the WASD keys are commonly used for movement in PC games because they are familiar to most players, and they allow a natural position for the hand on the keyboard. 3D platforming games typically use controller input rather than keyboard, as it allows smoother directional movement with a joystick as opposed to using arrow keys. I have chosen to offer both controller and keyboard input options for better user experience. \newline

Camera systems are essential in games to determine the player's perspective of the game world. Common types include first-person, third-person and top-down cameras, each providing different approaches to the gameplay design \cite{Kramarzewski2023}. First person cameras show the game through the eyes of the player character, which offers a more immersive experience. This is commonly used for first-person shooter games like Call of Duty where precise aiming is important. Third person cameras are positioned slightly above and behind the player character which provides a wider view of the area with more focus on the player character. It is typically used in adventure games and 3D platforming games like The Legend of Zelda series and Super Mario Galaxy. Top down cameras are typically used in puzzle or strategy games like Stardew Valley and provides a bird's eye view of the game world. Super Mario 3D world which I am taking some inspiration from, uses a fixed third person camera and this fits with the platformer/adventure theme of my game. \newline
Level design is an important aspect of creating a compelling user experience in video games. It involves the structure and layout of the game world, including the placement of obstacles, collectibles and enemies, to provide an engaging and challenging experience for players. A well-designed level should balance challenge and accessibility, encouraging exploration and rewarding players for their progress \cite{Kramarzewski2023}. In 3D platformers and action-adventure games, levels are often designed to cater to both "achievers" and "experiencers", players who prefer completing tasks vs players who prefer exploration \cite{zhao2022dynamic}.  My game will attempt to implement this approach by encouraging exploration even in fairly small levels.

%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in section \ref{HSM}.  I decided specifically to use a HSM for the player's movement as there was shared behaviour that I wanted to apply across multiple states without duplicating it into each one. For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure \ref{fig:label_State} details this architecture:
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_State}
\end{figure}
\newline The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and it's Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. I chose here to use the factory pattern for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}\label{physics}
In my game, I chose to use Unity's built in Character Controller for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics \cite{unity2024_charactercontroller}. In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In my game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why I have chosen the built-in Character Controller, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk upstairs and walk on slopes \cite{unity2024_charactercontroller_reference}. The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. I used this for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so I implemented the gravity and jump mechanics separately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, I used the following equations outlined by Kyle Pittman \cite{pittman2016_jump}:
\begin{equation}
\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
\end{equation}

\begin{equation}
\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
\end{equation}
\paragraph{}
\begin{verbatim}
private void SetupJumpVariables()
{
    float timeToApex = _maxJumpTime / 2;
    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
}
\end{verbatim}
For the gravity applied to the player while grounded, I used a smaller value of gravity to avoid unnecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

%%%%%%%%%%%%%%%%%%%%%%
%%% Enemies and Combat#
\section{Enemy Movement}\label{enemy_movement}
The enemy movement in the game is implemented dynamically based on the player's proximity. \color{red} There are two enemy types, long range and short range which both exhibit different movement behaviours. Short ranged enemies start in an idle state and begin to chase the player when they come within a specified range. Once the player moves out of this range, the enemies return back to their original starting position. Long ranged enemies that shoot the player from a distance stand still, and dynamically rotate to face and aim at the player. \color{black} To implement this behaviour with intelligent navigation I chose to use Unity's AI module, which supports AI pathfinding using NavMesh Surfaces and NavMeshAgents \cite{unity2024_AI}. 
A NavMeshAgent is assigned to each enemy, allowing them to navigate across a NavMeshSurface while avoiding obstacles in their path. These agents are configured with properties such as movement speed, acceleration, avoidance priority, and movement radius, which control their movement behaviour \cite{unity2024_NavAgent}. The NavMeshSurface is assigned to the level's entire terrain, defining the ground area that the enemies can move on. This approach allows enemies to intelligently avoid obstacles and dynamically chase the player while navigating complex environments. \newline
\subsection{Architecture}
Unlike the player movement system, I chose not to implement the State Machine design pattern for the enemy movement states. The enemy states: Idle, Chasing and Returning are relatively simple, and using a State Machine would likely overcomplicate the system for such few states. However I may consider refactor the system if more complex enemy types are introduced later in development, requiring additional states or behaviours. The current design is detailed in figure \ref{fig:label_enemyMovement}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyMovementUML.drawio}
    \caption{UML Class digram of Enemy Movement System}
    \label{fig:label_enemyMovement}
\end{figure}
The FollowRadius component detects when the player enters or exits the proximity radius. It makes use of a SphereCollider which calls OnTriggerEnter() and OnTriggerExit() when the player enters or exits the radius. It communicates this to EnemyMovement using events. 
\begin{verbatim}
private void OnTriggerEnter(Collider other) 
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if (damageable != null)
    {
        PlayerEnter?.Invoke();
    }
}
\end{verbatim}
EnemyMovement subscribes to the PlayerEnter and PlayerExit events from FollowRadius and begins manages the enemy's movement coroutines based on the event. A coroutine is a method that allows you to spread tasks across several frames. It can pause execution and return control to Unity but then continue where it left off on the following frame \cite{unity2024_Coroutines}. I chose to make use of coroutines instead of the Update() method which runs every frame. This is because the enemy movement relies on constant checks for position updates such as the player's position to follow, and using a coroutine allows this behaviour to execute over time without repeatedly checking every frame. One of the coroutines from EnemyMovement is shown below:
\begin{verbatim}
private IEnumerator FollowTarget()
{
    WaitForSeconds wait = new WaitForSeconds(_updateSpeed);
    while(enabled){
        if (Target != null)
        {
            _isMoving = _agent.velocity.magnitude > 0.1f;
            _animator.SetBool(_isMovingHash, _isMoving);
            _agent.SetDestination(Target.position); 
        }
        yield return wait;
    }
}
\end{verbatim}
\color{red} RangedEnemyMovement inherits from EnemyMovement, allowing different movement behaviour for long ranged enemies. It overrides the OnPlayerEntered and OnPlayerExit methods from EnemyMovement to start and stop an aiming coroutine when the player enters or exits the FollowRadius. This enables the Enemy class to use two different movement types interchangeably depending on the enemy type, similarly to the strategy pattern.  \color{black}
The Enemy class manages the overall behaviour and state of the enemies in the game. Concerning movement, it is responsible for configuring the properties of the NavMeshAgent (such as speed and stopping distance) but delegates the actual movement logic to the EnemyMovement \color{red} or RangedEnemyMovement classes \color{black}. This separation allows the Enemy class to keep its focus on managing overall enemy behaviours while delegating the more complex logic to other dedicated classes. For movement, it works with the EnemyMovement class, while for combat, it interacts with the AttackRadius class (Detailed in \ref{combatsystem}). 

\subsection{Configurable Enemies}
Currently in the game there are \color{red} three \color{black} enemy types, Goblin Warrior, Scout \color{red}and Archer. Warrior and Scout are both \color{black} short range and vary in attack speed, health and movement speed. \color{red} Archer is a long ranged enemy with differing attack speed, health and movement properties to Warrior and Scout. \color{black} To enable multiple enemy types I used the Strategy pattern \ref{strategy} in conjunction with Unity's ScriptableObject feature. I chose to use Strategy here to enable the Enemy class to use different behaviours interchangeably without hardcoding multiple Enemy classes for different enemy types. Unity's ScriptableObject is a data container that allows you to create customisable assets in the Unity editor \cite{unity2024_ScriptableObject}. I used this along with the Strategy pattern methodology to create separate configurable data containers for the \color{red}three \color{black} different enemy types. This design is detailed in figure \ref{fig:label_strategy}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyStrategyUML.drawio}
    \caption{UML Class diagram of Enemy Strategy Pattern.}
    \label{fig:label_strategy}
\end{figure}
The EnemyScriptableObject stores all the customizable parameters, such as health, attack speed, and movement speed. The Enemy class uses the data from the assigned ScriptableObject (GoblinWarrior, GoblinScout \color{red}or GoblinArcher\color{black}) to adjust its behaviour dynamically. This approach decouples the enemy configuration from the core enemy logic, allowing new enemy types to be added easily by creating new ScriptableObjects without modifying the Enemy class. 

\section{Combat System}\label{combatsystem}
The combat system is a core feature of the game, enabling attack and damage mechanics between the player and enemies. The design focusses on handling the damage mechanic in a consistent way across both enemies and player, while accommodating their differing attack mechanics. This was achieved by creating an IDamageable interface, which must be implemented by all game objects capable of taking damage. This design is detailed in figure  \ref{fig:label_combat}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/CombatUML.drawio.png}
    \caption{UML Class diagram of Combat System}
    \label{fig:label_combat}
\end{figure}
The IDamageable interface is the core of the system, which defines a TakeDamage() method which reduces the entity's health based on an incoming damage value. Both the Enemy and PlayerHealthAndDamage classes implement this interface, ensuring damage is applied in a consistent way for both entities. 
\newline The player's combat mechanic is controlled by the WeaponAttributes class. The weapon is equipped with a Box Collider that calls the OnTriggerEnter() method on collision. Within OnTriggerEnter(), the TakeDamage() method is called on the enemy that entered the collider. 
\begin{verbatim}
private void OnTriggerEnter(Collider other)
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if(damageable != null)
    {
        // Call takedamage method on enemy
        damageable.TakeDamage(damage);
    }
}
\end{verbatim}
The WeaponManager class manages the weapon's Box Collider, ensuring that it is only enabled during the player's attack animation. This is achieved with Unity animation events, which call the EnableWeaponCollider() method at the appropriate time during the attack animation.\newline 
The enemy's combat system differs from the player's, as it does not rely on weapon collision mechanics. Instead, the AttackRadius class manages the enemy's attack behaviour. This system uses a Sphere Collider that defines a radius in which the player can take damage. When the player is within this radius, the enemy periodically attacks by calling the player's TakeDamage() method. The  attacks are based on a set delay, allowing different enemy types to vary in attack speed. The Attack coroutine from AttackRadius is shown below:
\begin{verbatim}
protected virtual IEnumerator Attack()
{
    WaitForSeconds wait = new WaitForSeconds(_attackDelay);

    // Keep attacking as long as the player is within the radius and the enemy can attack
    while (_damageable != null)
    {
        if (GetComponentInParent<Enemy>().CanAttack)
        {
            OnAttack?.Invoke(_damageable);
            _damageable.TakeDamage(_damage);
        }
        yield return wait; // Wait before the next attack
    }

    _attackCoroutine = null;
}
\end{verbatim}
\color{red} All enemy types in the game can be stunned after being hit by the player. When stunned, enemies are unable to attack until the 'get hit' animation has ended. This is controlled by a CanAttack variable defined in the Enemy class, which is checked in the Attack coroutine to determine when the enemy can attack. RangedAttackRadius provides the attack logic for the Archer enemy, which inherits from AttackRadius. This enemy begins firing arrows periodically while aiming at the player when the player has entered the RangedAttackRadius, and stops when they've left the radius. To achieve this behaviour, the Object Pool pattern \ref{objectpool} was used to manage the creation of arrows. This pattern avoids repeatedly creating and destroying arrows, improving performance. The architecture for this is shown in \ref{fig:label_objpool} below:
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/ArrowPoolUML.drawio.png}
    \caption{UML Class diagram of Object Pool Pattern}
    \label{fig:label_objpool}
\end{figure}
The ObjectPool class manages a pool of reusable objects, which in this case would be the arrows. It keeps a list (\_availableObjectsPool) of available objects to be used, and provides methods for creating a pool of objects, getting an available object to use from that pool and returning already used objects back to the pool. PoolableObject represents an object to be used in the object pool, defining a method to ensure objects that inherit from this class are returned to the object pool once disabled. The Arrow class manages the arrow prefab that will be used in the object pool, which inherits from PoolableObject. It defines all of the arrow's properties and handles dealing damage to the player on collision. RangedAttackRadius overrides the Attack coroutine from AttackRadius to implement this new behaviour shown below:
\begin{verbatim}
protected override IEnumerator Attack()
{
    WaitForSeconds Wait = new WaitForSeconds(_attackDelay);
    yield return Wait;

    // Continue attacking while there is still a target
    while (_damageable != null)
    {
        _agent.isStopped = true;

        // Get an available arrow from the pool
        PoolableObject poolableObject = _arrowPool.GetObject();
        if (poolableObject != null)
        {
            // Set up the arrow's properties
            _arrow = poolableObject.GetComponent<Arrow>();
            _arrow.Damage = _damage;
            _arrow.transform.position = transform.TransformPoint(_arrowSpawnOffset);
            _arrow.transform.rotation = _agent.transform.rotation;

            // Apply force to the arrow in the direction that the enemy is facing
            _arrow.Rigidbody.AddForce(_agent.transform.forward * _arrowPrefab.MoveSpeed, ForceMode.VelocityChange);
            InvokeOnAttack(_damageable);
        }
            
        yield return Wait;
    }

    _attackCoroutine = null;
}
\end{verbatim}
Each time the ranged enemy attacks, it gets a new available arrow from the object pool using GetObject(). Then the properties of the arrow are confgured, including the damage it does and its spawn position in relation to the enemy. The Arrow prefab uses a Rigidbody component, as discussed in section \ref{physics}, which allows it to use and react to physics. This allows for a force to be applied to the arrow, shooting it in the direction of the player at a specific speed. 
\color{black}




%%%%%%%%%%%%%%%%%%%%%%
%%% Animals and Cages
\section{Animals and Cages}
\color{red} The main gameplay mechanic of the game is rescuing animals around the map. In each level there are three animals stuck within cages that are guarded by enemies for the player to find and rescue. To rescue an animal the player has to defeat the enemies that surround the animal's cage. The amount of enemies surrounding each cage varies to increase/decrease the difficulty of the parts of each level. Once the player rescues an animal they break free from the cage and follow the player around the map. The architechture of this mechanic is detailed in figure \ref{fig:label_rescue} below. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/AnimalRescueUML.drawio.png}
    \caption{UML Class diagram of Animal Rescue Mechanic}
    \label{fig:label_rescue}
\end{figure}
The Cage class controls the logic for freeing animals once all assigned enemies have been defeated. Each cage has a list of associated Enemy objects that are assigned to each specific cage in the Unity editor. The class subscribes to the OnDefeated event of each of it's associated enemies, allowing it to be notified when one of them dies. Each time OnEnemyDefeated is triggered, the cage checks if all assigned enemies in the list have been defeated. Once this condition is met, the FreeAnimal() method is called, which handles the visual and sound effects for the cage's destruction and prompts the animal to start moving. The Animal class manages this movement behavior which includes staying idle inside the cage until freed. Once freed, the Cage script calls the Animal's StartFollowing() method which allows the Animal to follow the player. The follow movement uses the same logic that the Enemy movement uses to chase the player, discussed in section \ref{enemy_movement}. To prevent animals from getting stuck around the map far from the player, a teleportation system ensures they remain near the player. The TeleportRadius class represents a sphere collider around the player for this system. If an animal exits this radius, it calls the Animal's TeleportToPlayer() method, ensuring they stay within a reasonable distance of the player.
\color{black}


%%%%%%%%%%%%%%%%%%%%%%
%%% User Experience#
\section{User Interface}
\color{red} The design of the user interface (UI) is an important part of enhancing the overall user experience for the game, as discussed in section \ref{userexperience}. Therefore creating a full UI was a large focus of the development to achieve a complete and professional looking game that is intuitive for the player to use. The UI includes a title screen, level selection menu, settings and pause menus and a HUD (Heads Up Display) for the levels.  \newline
To set up the UI components, \color{black} I made use of Unity's built-in UI package \cite{unity2024_UI} to create multiple canvases to display various types of information to the user. 
For communication between the UI elements involving health changes and relevant game objects, the Observer pattern was used, as discussed in section \ref{observer}. \color{red} The pattern was used \color{black} in this context to decouple the UI components from the game logic. This allows the game objects to act as subjects, and notify the relevant UI components (observers) without needing to hold direct references to them. Currently, there are two subjects (the enemy and player), and three observers (the enemy and player's health bars and the game over screen). This design is shown in figure \ref{fig:label_observer1}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/HealthObserverUML.drawio.png}
    \caption{UML Class diagram of Health Observer Pattern}
    \label{fig:label_observer1}
\end{figure}
There are two interfaces to manage health changes: one for the subject and one for the observers. The IHealthSubject interface defines methods for registering, unregistering and notifying observers about health changes. The IHealthObserver interface specifies an OnNotify() method, that passes the observer the updated health value and defines what it should do given the new value. 
The PlayerHealthAndDamage and Enemy classes implement the IHealthSubject interface. Each holds a list of observers that are managed with the register and unregister observer methods. When a health change happens, the subjects notify their observers by calling the OnNotify() method for each observer in the list.  
\begin{verbatim}
public void NotifyHealthObservers()
{
    foreach (IHealthObserver observer in _observers)
    {
        observer.OnNotify(_maxHealth, _health);
    }
}
\end{verbatim}
The PlayerHealthBar, EnemyHealthBar and GameOver classes implement the IHealthObserver interface. The Game Over screen needs to observe the player's health and subsequently pop up if their health is below zero. 
The health bars observe the player and enemies to display their current health in real time. Each observer registers itself with its associated subject by calling the subject's RegisterHealthObserver(this) method. Once registered, the subject calls the observer's OnNotify() method whenever there is a health update. For example, when an Enemy notifies the EnemyHealthBar, the following method is called:
\begin{verbatim}
public void OnNotify(float maxHealth, float currentHealth)
{
    UpdateHealthBar(maxHealth, currentHealth);
}
\end{verbatim}

\color{red} Beyond the player and enemy health bars, there are some other UI elements displayed on the HUD. The progression of the level is shown to the user through the UI, with the HUD and level cleared screen. When the player begins the level, the current quest, (find and rescue the animals) is displayed on the HUD. As each animal is rescued the HUD is updated to display how many animals have been rescued, and once they all have, a new quest (reach the goal) is displayed and the goal becomes activated, shown through visual effects surrounding the goal. Once the player walks into the goal, a level complete screen is shown with the player's time and score, this is illustrated in figures \ref{fig:label_goal} and  \ref{fig:label_levelcleared} below:

Beyond the player and enemy health bars, additional UI elements are displayed on the HUD to communicate the player's progression through the level. At the start of a level, the HUD displays the current objective: "Rescue the animals". Then, as animals are rescued, the HUD updates dynamically to display the number rescued out of the total. Once all animals have been freed, the objective changes to "Get to the goal," and the goal is activated with a collider and visual effects to highlight its location. When the player walks into the goal collider, a level cleared screen appears, displaying the player's time and score. These events are shown in Figures \ref{fig:label_goal} and \ref{fig:label_levelcleared}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/Goal.png}
    \caption{Goal Activated}
    \label{fig:label_goal}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelComplete.png}
    \caption{Level Cleared Screen}
    \label{fig:label_levelcleared}
\end{figure}

The architecture for the level progression is detailed in figure \ref{fig:label_levelprogression} below:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelProgressionUML.drawio.png}
    \caption{UML Class diagram of Level Progression}
    \label{fig:label_levelprogression}
\end{figure}

The UIQuestManager manages the quest system by tracking the number of rescued animals, updating the quest dialog, and activating the goal when all animals have been freed. The Animal class defines an OnRescued event, which UIQuestManager subscribes to in order to be notified whenever an animal is rescued. Each time UIQuestManager is notified of this event, it updates the count on the HUD and checks whether all animals have been rescued. If so, it changes the quest dialog and activates the goal. The OnAnimalRescued method, which handles this logic, is shown below:
\begin{verbatim}
private void OnAnimalRescued()
{
    _rescuedAnimals++;
    _rescuedAnimalsText.text = $"{_rescuedAnimals}/{TotalAnimalsToRescue}"; // Update UI

    // If all animals have been rescued, show new quest and activate the goal
    if (_rescuedAnimals >= _totalAnimalsToRescue && !_allAnimalsRescued)
    {
        _allAnimalsRescued = true;
        StartCoroutine(TransitionToSecondQuest());
        ActivateGoal();
    }
}
\end{verbatim}
The ActivateGoal() method enables the GoalRadius object and instantiates the visual effect that signals the goal’s activation. GoalRadius represents the collider that the player must enter to complete the level. When the player collides with it, the OnTriggerEnter() method triggers the Setup() method in the LevelCleared class, which manages the level completion screen.
LevelCleared retrieves the elapsed time from GameTimer and the total score from the ScoreManager to display them on the UI. The ScoreManager tracks the player’s score throughout the level by subscribing to the Enemy class's OnDefeat event. Each time an enemy is defeated, its score is added to the total. When LevelCleared retrieves this value, it combines it with the completion time and applies a score multiplier, rewarding players for defeating more enemies and finishing the level quickly. The Setup() method from LevelCleared, which handles this logic, is shown below:
\begin{verbatim}
public void Setup()
{
    // Activate the UI screen and change the game state
    gameObject.SetActive(true);
    LevelManager.Instance.SetGameState(LevelState.LevelCleared);

    // Play sound effect
    SoundFXManager.instance.PlaySoundFX(_levelClearedClip, transform, 1f);

    // Get the time from the game timer and convert it to minutes and seconds
    float elapsedTime = _timer.ElapsedTime;
    int minutes = Mathf.FloorToInt(elapsedTime / 60);
    int seconds = Mathf.FloorToInt(elapsedTime % 60);
    _timeText.text = $"{minutes:D2}:{seconds:D2}";

    // Get score from the score manager and add on the elapsed time
    float finalScore = (_score.Score + elapsedTime) * 10;
    _scoreText.text = $"{finalScore:N0}";
}
\end{verbatim}

Another important aspect of the UI is managing gameplay pausing during specific UI screens, such as the pause menu or game over screen, and allowing different classes to respond based on the current game state. To achieve this, the LevelManager class handles transitions between the key game states: Playing, Paused, LevelCleared, and GameOver.
This class uses the Singleton pattern, as discussed in Section \ref{singleton}, ensuring that the game state can be read globally without requiring direct references in multiple classes. Additionally, it guarantees that only one instance of LevelManager exists per level. The architecture of this system is illustrated in Figure \ref{fig:label_singletonLevelManager}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/LevelManagerSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonLevelManager}
\end{figure}

The LevelManager implements a simple Finite State Machine (FSM) as discussed in section \ref{HSM} , managing game states using a LevelState enum to represent each level state, as each state requires minimal behavior. The SetGameState() method transitions the game to a new LevelState when called, typically triggered by UI screens associated with those states. For example, when the pause menu is activated, it calls \texttt{LevelManager.Instance.SetGameState(LevelState.Paused)}, and the LevelManager handles pausing the game accordingly. Within SetGameState(), the method determines the new state and executes the appropriate logic. For instance, in the Paused state, EnableGameplay() is called to stop gameplay. Additionally, other classes can query the LevelManager to check the current game state, allowing them to execute state-specific logic only when necessary.\newline

The game also implements animated scene transitions to create a smoother and more visually appealing UI experience when navigating through menus for the user. Initially, each UI menu class contained its own button logic for loading scenes, resulting in duplicated code across multiple menu classes. The Title Screen, Level Select and each level are each a seperate scene, most buttons, except for the pause and resume buttons within a level, take the user to a different scene. To improve maintainability and implement animated scene transitions, the button logic was refactored into a dedicated SceneLoader class. The architecture of this class is illustrated in \ref{fig:label_SceneLoader} below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{UMLDiagrams/SceneLoaderUML.drawio.png}
    \caption{UML Class diagram of SceneLoader class}
    \label{fig:label_SceneLoader}
\end{figure}

In Unity, UI buttons are components that can be attached to UI objects in a scene, each with an OnClick event that allows a method from any class to be assigned. In the game, all UI buttons reference the SceneLoader class in their OnClick events, ensuring a consistent approach to scene transitions. The SceneLoader class provides a LoadScene() method, which takes the name of the scene to load as a string, triggers the transition animation, and then loads the new scene. It also includes an ExitGame() method for buttons that allow the player to quit the game. The transition animation is handled by an object with an Animator component. When a scene loads, this object starts by covering the screen and then plays an animation to reveal the new scene. Within SceneLoader, when a button is pressed, the animator is triggered to play the 'hide' animation, and the scene transition is delayed for the duration of this animation before the new scene is loaded. This ensures smooth and visually appealing transitions between UI screens.
\color{black}

\section{User Experience}
User experience focuses on ensuring that the game is enjoyable and accessible for the player, which includes considerations for controls, camera movement, feedback mechanisms and interface design, as discussed in section \ref{userexperience}. 
\subsection{Camera \& Controls}
For the camera movement, a fixed third-person perspective was implemented, \color{red} as discussed in section \ref{userexperience}.  The camera stays positioned behind the player and follows their movements without allowing the player to control its angle or view. 
This camera perspective was chosen because it is the approach used in the games that this project takes inspiration from, Super Mario 3D World and The Legend of Zelda: Link’s Awakening for Switch. Given the relatively small level sizes, full camera control is unnecessary, as the fixed perspective provides a clear view of most of the environment. Additionally, the third-person view ensures that the player can clearly see their character’s movements, which is essential for both platforming and action gameplay. \color{black}
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/PlayerCamera.png}
        \caption{FreeLook Camera on Player}
        \label{fig:label_camera}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{OtherImages/Zelda.png}
        \caption{Camera from Link's Awakening}
        \label{fig:label_linkcamera}
    \end{subfigure}
    \caption{Comparison of the game's camera system with Link's Awakening}
\end{figure}

To achieve smooth and dynamic camera movement for this scenario, Unity's Cinemachine package was used. Cinemachine allows you to create professional looking camera movement with automatic damping and target tracking \cite{onewheelstudio_2021}. The FreeLook camera that Cinemachine provides was used to create the third person camera as shown in figure \ref{fig:label_camera}
Cinemachine allows you to define different camera properties such as follow speed and field of view to achieve the best perspective that would show a sufficient view of the world within the camera. \newline
As discussed in \ref{userexperience}, player controls are an important factor towards offering a great user experience. To allow the player to use either keyboard inputs or game controller inputs, Unity's new Input System was used. The input system allows players to control the game in a variety of ways including external devices, touch screen or gestures \cite{unity_2024_inputsystem}. This is done by setting up 'Actions' such as running, which can have multiple input options linked to it. For example the run action is linked to both the Left Shift key on the keyboard, and the Left Trigger button on a controller. Below is an example of how the directional movement input is read using the corresponding input action:
\begin{verbatim}
private void OnMovementInput(InputAction.CallbackContext context)
{
    Vector2 input = context.ReadValue<Vector2>();
    _currentMovementInput = input;
    _isMovementPressed = input != Vector2.zero;
}
\end{verbatim}
OnMovementInput is triggered when the movement input action is performed (Joystick or WASD key movements) and provides 'context' of the action. In this case we read the input as a two dimensional vector in the direction that the player is pressing, which is then used for the Move() method of the Character Controller \ref{physics}.  \newline

\subsection{Level Design}
One of the objectives for the project surrounding user experience was to design three levels of varying difficulty. A key aspect of level design is to keep a balance between challenge and accessibility for all levels of players as discussed in \ref{userexperience}. \color{red}Since this game is aimed at all ages, it was important to start with a very easy introduction and gradually increase the difficulty. The three levels are of progressive difficulty, with the first level starting as an introduction to the game’s mechanics. Ideally, with more time, this could have been expanded into a dedicated tutorial level with full instructions on controls and core mechanics. For now, level one is designed to be linear, ensuring that players naturally encounter animals to rescue and enemies to fight without needing to search for them. The first enemies appear individually and are easy to defeat, allowing the player to learn combat mechanics in a low pressure environment. Additionally, two collectible hearts are placed in accessible locations to help players restore their health as they progress. An overview of this level is shown in figure \ref{fig:label_LevelOne}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelOne.png}
    \caption{Overview of Level One Layout}
    \label{fig:label_LevelOne}
\end{figure}

The second and third levels increase in difficulty compared to the first, with groups of two enemies guarding most cages. Unlike level one, these levels are less linear, requiring more exploration to find collectible hearts and animals to rescue. Level three presents the greatest challenge, incorporating more difficult platforming sections and additional enemies beyond those guarding cages, encouraging players to engage in combat for a higher score. This level design aimed to keep a balance between platforming and exploration while keeping the environments fairly small to maintain a short and lighthearted gameplay experience. An overview of these levels are shown in figures \ref{fig:label_LevelTwo} and \ref{fig:label_LevelThree}. \newline

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelTwo.png}
    \caption{Overview of Level Two Layout}
    \label{fig:label_LevelTwo}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/LevelThree.png}
    \caption{Overview of Level Three Layout}
    \label{fig:label_LevelThree}
\end{figure}




Across all levels, each type of enemy keep the same health and damage values, determining how much damage they deal to the player and how difficult they are to defeat. Similarly, the player has fixed health and attack statistics. Balancing these values was a challenge, as it was important to ensure that enemies were neither too easy or too difficult to defeat, and similarly for the player character. These values were refined through playtesting conducted in the first term of the project, as discussed in section \ref{testing}, where feedback was gathered informally from a few users on how the difficulty could be adjusted. This continued in the second term with more formalised feedback via a user feedback form (detailed in section \ref{reflection}). The results indicated that the majority of players found the gameplay to be easy, as shown in figure \ref{fig:label_difficultyfeedback}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{OtherImages/DifficultyFeedback.png}
    \caption{User Feedback Survey Results}
    \label{fig:label_difficultyfeedback}
\end{figure}

When asked to provide additional feedback on difficulty, three users suggested increasing the enemy difficulty, either by raising their attack power or increasing their numbers in each level. Based on this feedback, the attack power of two of the weaker enemies (archer and scout) was increased to make them more challenging for the player. However, achieving a perfect balance would require further rounds of playtesting and feedback.


\subsection{UI Design}

-discuss UI and the feedback chart \newline

Another thing that was taken into consideration is the layout and design of items on the heads up display (HUD) to provide information about the status of the player and level in a clear and helpful way. The HUD contains the player's health, a count of how many animals they've rescued out of the total, the quest task and the game timer. Again, through informal playtesting the current layout was decided on, keeping the quest information in the top left corner, health in the bottom left and the timer in the top right. This is shown in figure \newline
- still need to reword this properly and discuss chart




\color{black}

\subsection{Sound Design}


- Sound FX stuff
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{UMLDiagrams/SoundFXSingletonUML.drawio.png}
    \caption{UML Class diagram of Singleton Pattern}
    \label{fig:label_singletonSoundFX}
\end{figure}

\section{Optimisation}
\color{red}
- Frustum Culling\newline
- LOD groups for terrain\newline
- NavMesh for pathfinding (preset data rather than realtime pathfinding)\newline
- Object pooling\newline
- Reduced physics calculations with collision matrix\newline
\color{black}
\section{Testing}\label{testing}
User testing is crucial in game development, as it provides real-world feedback on gameplay mechanics, usability and player satisfaction. This helps developers find and fix bugs, refine mechanics and enhance the user interface \cite{flashjungle_2022}. This term, I focused on conducting playtesting, a type of user testing that evaluates gameplay mechanics. Other types of user testing include usability testing and beta testing. Usability testing assesses how easily players can navigate the game and understand it's UI, and Beta testing involves testing a nearly complete version of the game in real world conditions to address bugs \cite{flashjungle_2022}. Since the game is still in development, with an incomplete user interface, I will not conduct usability or beta testing until term two. To conduct playtesting I asked different people to play the game and get feedback on what could be better about the gameplay mechanics like the player's movement and combat system. From this I received feedback that helped me better the player's jump, and refine different enemy statistics.
%%%%%%%%%%%%%%%%%%%%%%
%%% Reflection and Evaluation
\chapter{Reflection and Evaluation}\label{reflection}

%%%%%%%%%%%%%%%%%%%%%%
%%% Professional Issues
\chapter{Professional Issues}

- Legal things to consider when publishing game
- Legal stuff with assets
- Legal stuff with unity engine

- Part 2 on if i made the game open source for others to work on what would be involved in that and how would i manage that

\color{red} Game development involves various professional and ethical considerations, particularly in legal compliance and asset usage when publishing a game commercially. Throughout this project, I have had to consider licensing restrictions when using third-party assets and the legal requirements of publishing a game using Unity engine. This section discusses these issues and how they should be addressed professionally if this project were to be published. \newline

The majority of assets used in the game were sourced from the Unity Asset Store, which provides a large variety of assets that you can download and use in Unity Engine. Most assets from the Unity Asset Store are royalty-free on purchase or free download, except for ones labeled as 'restricted', which cannot be used commercially. Any restrictions are detailed in the description of the asset in the store \cite{UnityCommercial}. However, it is important to ensure the correct license type is purchased when downloading an asset for commercial use.
All Unity assets fall under either Extension, Single Entity, or Multi Entity licence types. Extension assets cover any assets found under the 'tools' category in the store, and users are required to purchase one seat per user that has access to the raw asset files \cite{UnityLicences}. Single Entity and Multi Entity assets can be any other type of asset that doesn't fall under the 'tools' category. Single Entity assets are typically for single users or companies, and permits use by all team members within a single company. Multi Entity assets cover parent, child and sister companies, as well as contractors on a project, allowing them access to the raw asset files across different branches of an organization \cite{UnityLicences}. Currently, all assets used in the game fall under either the Extension or Single Entity license types. As the only developer working on the game, I am a single entity, meaning these assets can be used royalty-free if the game was published commercially, and any Multi Entity licences would not need to be purchased. Failing to purchase the correct asset licenses can lead to a game being removed from distribution platforms and may result in legal disputes.

When publishing a game commercially using Unity engine, it is important to determine whether a paid Unity license is required and what tier is appropriate. Unity offers several licensing plans, with the main options being Unity Personal, Pro, Enterprise, and Industry. Unity Personal is free and intended for individual developers, while the paid tiers are designed for businesses and larger organizations.
Games can be published commercially using any of these plans, including Unity Personal. However, whether an upgrade to a paid license is required depends on 'total finances', which Unity defines based on revenue and funding. If a developer is providing services to a third party, total finances are measured by the client’s total revenue and funding, regardless of the source. If the developer is not providing services to a third party, total finances are determined by the total revenue and funding generated through the use of Unity. For governmental, non-profit, educational, or academic institutions, total finances are based on the entity’s entire budget \cite{UnityTC}.
Each licensing tier has a maximum limit on total finances for eligibility. If this limit is exceeded, the user will have to upgrade to the tier that they are elegible for to continue using Unity engine. For this project, the game was developed using Unity Personal, which allows for the game to be published commercially. However, if my total finances were to exceed the \$200,000 USD threshold, upgrading to a Unity Pro license would be required. Using the wrong Unity license would violate Unity's terms of service and could result in restrictions on both the use of the engine and the distribution of games created with it.






\color{black}

%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}
\section{Code Style}
Below is the code style I decided on, following Unity's guidelines \cite{unity_2022_codestyle}.
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{8cm}|}
\hline
\textbf{Aspect}              & \textbf{Chosen Convention}                                                                                   \\ \hline
\textbf{Field Naming}        & Private fields use camelCase with a leading underscore (e.g., \texttt{\_health}, \texttt{\_animator}). Public fields use PascalCase. \\ \hline
\textbf{Property Naming}     & Public properties use PascalCase (e.g., \texttt{Health}, \texttt{MaxHealthReadOnly}).                         \\ \hline
\textbf{Interface Naming}    & Interface names start with "I" and describe behavior (e.g., \texttt{IDamageable}, \texttt{IHealthSubject}).   \\ \hline
\textbf{Event Naming}        & Events are named with verb phrases and often follow "OnEventName" format (e.g., \texttt{DoorOpened}).         \\ \hline
\textbf{Method Naming}       & Methods use  PascalCase (e.g., \texttt{TakeDamage}, \texttt{AddHealth}).                    \\ \hline
\textbf{Braces Style}        & Always include braces even for single-line conditional statements (e.g., \texttt{if (condition) \{ DoSomething(); \}}). \\ \hline
\textbf{Files per Class}     & Each class resides in its own file, and file names match MonoBehaviour class names (e.g., \texttt{PlayerHealthAndDamage.cs}). \\ \hline
\end{tabular}
\caption{Code Style Conventions Followed in the Project}
\label{tab:codestyle}
\end{table}

\section{Development Diary}
\textbf{Week 11}\newline
06/12/2024
\newline- Bugfix to player's NavMeshAgent which was causing the agent to not relocate to the player when they leave the NavMeshSurface.
\newline- Bugfix to the heart idle animation which was overriding the positions of all hearts in the scene.
\newline- Finalised level one layout
\newline04/12/2024
\newline- Refactored the UI system to use the observer pattern.
\newline03/12/2024
\newline- Added collectible hearts which increase the player's health.
\newline02/12/2024
\newline Redesigned layout and environment for level one.

\textbf{Week 10}\newline
27/11/2024
\newline- Created a second melee enemy which is faster and does less damage.
\newline25/11/2024
\newline- Created the HUD (Heads Up Display) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters its follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured its movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage

\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{OtherImages/FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name2}
\end{figure}
The Assets folder contains all of the work I have completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram highlights the most important subfolders, such as the scripts folders, where all my C\# scripts are organised. Note that not all folders are included in the diagram. \newline

Files Relevant to the Player State Machine (Assets/Fighter/Scripts):
\begin{itemize}
    \item \texttt{ PlayerBaseState.cs, PlayerRunState,cs, PlayerJumpState.cs, PlayerStateMachine.cs, PlayerStateFactory.cs} (There are other state files within this folder, Jump and Run are just two examples)
\end{itemize}

Files relevant to the combat system:
\begin{itemize}
    \item \texttt{IDamageable.cs} (Assets/Interfaces)
    \item \texttt{PlayerHealthAndDamage.cs, WeaponManager.cs, WeaponAttributes.cs} (Assets/Fighter/Scripts)
    \item \texttt{Enemy.cs, AttackRadius.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to enemy movement:
\begin{itemize}
    \item \texttt{Enemy.cs, FollowRadius.cs, EnemyMovement.cs, EnemyScriptableObject.cs} (Assets/CuteGoblins/Scripts)
\end{itemize}
Files relevant to the user interface:
\begin{itemize}
    \item \texttt{IHealthSubject, IHealthObserver} (Assets/Interfaces)
    \item \texttt{PlayerHealthBar.cs, EnemyHealthBar.cs, GameOver.cs} (Assets/UI/Scripts)
\end{itemize}
Files relevant to animal rescue:
\begin{itemize}
    \item \texttt{Cage.cs} (Assets/CuteRaccoons/Scripts)
    \item \texttt{IDefeatSubject.cs, IDefeatObserver.cs} (Assets/Interfaces)
\end{itemize}




\section{Demo Video Link}
\url{https://youtu.be/4mPIEk5YFJI}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\bibliographystyle{plain}
\raggedright
\bibliography{references}

\renewcommand{\bibname}{Assets Used}
\begin{thebibliography}{99}

\bibitem[25]{skybox} Key Mouse. Customizable Skybox. Available at: \url{https://assetstore.unity.com/packages/2d/textures-materials/sky/customizable-skybox-174576}

\bibitem[26]{forest_textures} Proxy Games. Stylized Nature Kit Lite. Available at: \url{https://assetstore.unity.com/packages/3d/environments/stylized-nature-kit-lite-176906}. 

\bibitem[27]{VFX} Lana Studio. Hyper Casual FX. Available at: \url{https://assetstore.unity.com/packages/vfx/particles/hyper-casual-fx-200333}.

\bibitem[28]{player} SEMA Game Studio. Modular Cute Fantasy Character Pack \#1. Available at: \url{https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy/modular-cute-fantasy-character-pack-1-293865}

\bibitem[29]{sound_effects} SURIYUN. Monsters Forest Pack 2. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/monsters-forest-pack-2-251936}. 

\bibitem[30]{sound_effects} Meshtint Studio. Forest Ruins Pack Cute Series. Available at: \url{https://assetstore.unity.com/packages/3d/environments/fantasy/forest-ruins-pack-cute-series-182412}. 

\bibitem[31]{sound_effects} Lost Panda Games. Low Poly Cartoon Item Pack - 3D. Available at: \url{https://assetstore.unity.com/packages/3d/props/low-poly-cartoon-item-pack-3d-274991}. 

\bibitem[32]{sound_effects} SURIYUN. Cute Goblin. Available at: \url{https://assetstore.unity.com/packages/3d/characters/creatures/cute-goblin-225492}. 

\end{thebibliography}

\label{endpage}

\end{document}

\end{article}
