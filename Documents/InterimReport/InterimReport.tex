\documentclass[]{final_report}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{array}
\usepackage{xcolor} % Added package for text coloring
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{forest}

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 

\vskip3em

Signature:

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
- 100-200 words \newline
- What does this report cover? \newline

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Objectives

\chapter{Objectives}
- Objectives you agreed on from the specification of the project
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
- Context \& motivation \newline
- Game concept description \& mechanics \newline
- Brief description of what is in the report \newline


%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
\section{Architecture}
\subsection{Hierarchical State Machine}\label{HSM}
The Hierarchical State Machine (HSM)  is a variation of the standard Finite State Machine (FSM) design pattern. The FSM pattern addresses player/object states for example, walking, idle and running and encapsulates each as an object. This pattern solves two problems: an object should change itâ€™s behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states (Unity Technologies, 2022). I will use this for the player's movement, as the player is the most complex game object in terms of states. Using a state machine simplifies the process of adding new states without affecting existing ones.  It ensures all states are handled consistently, avoiding conflicts. A HSM builds on the concept of FSM by adding a hierarchy of states, allowing shared behaviours across multiple states. This includes super states and sub states, which can run simultaneously. Super states manage the shared behaviour across the substates, while the substates define specific actions.
- Description \& explanation of all the concepts you used so far with citations. Best to put it into sections like '1.1' so you can reference them later on \newline
- Game engine choice  \newline
- What is involved in making a game  \newline
 
%%%%%%%%%%%%%%%%%%%%%%
%%% Planning & Timeline
\chapter{Planning \& Timeline}
- Re write timeline from the project plan and indicate any changes from the original plan\newline
The project timeline is divided into two terms. Term 1 focuses on developing and refining the core game mechanics, while Term 2 is dedicated to expanding features and optimising performance.

\subsection{Term 1}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1: & \textcolor{black}{|} & $\bullet$ & Learning and understanding the fundamentals of Unity game engine \\
Week 2: & \textcolor{black}{|} & $\bullet$ & Finalise the core game concept and gather all assets \\
Week 3-4: & \textcolor{black}{|} & $\bullet$ & Prototyping: Animations and movement for player and enemies\\
Week 5-6: & \textcolor{black}{|} & $\bullet$ &  Prototyping: Enemy interactions and health mechanics \\
& \textcolor{black}{|} & $\bullet$ & \textbf{Initial player and enemy movement prototype working by Week 7} \\
Week 7-8: & \textcolor{black}{|} & $\bullet$ & Design and User Interface: First level design and creating base user interface screens\\
Week 9: & \textcolor{black}{|} & $\bullet$ & Initial play-testing: Bug fixing and gathering feedback from users to refine core gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Level one finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on interim report and presentation \\
\end{tabular}

\subsection{Term 2}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1-3: & \textcolor{black}{|} & $\bullet$ & Feature Expansion: Multiple levels, score system, weapon upgrades\\
Week 4-5: & \textcolor{black}{|} & $\bullet$ & Audio and sound effects implementation \\
Week 6-7: & \textcolor{black}{|} & $\bullet$ &  Improvements to current graphics and game optimisation \\
Week 8: & \textcolor{black}{|} & $\bullet$ & Improving and expanding on current mechanics \\
Week 9-10: & \textcolor{black}{|} & $\bullet$ & Final play-testing : Bug fixing and gathering feedback from users to refine style and gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Final game with expanded features finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on final report \\
\end{tabular}
%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
 - Possibly info about unity engine \& why I chose it
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in section \ref{HSM}.  I decided specifically to use a HSM for the player's movement as there was shared behaviour that I wanted to apply across multiple states without duplicating it into each one.  For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure 1.5 details this architecture:
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_name}
\end{figure}
\newline The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and it's Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. I chose here to use the factory pattern for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}
In my game, I chose to use Unity's built in Character Controller for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics (Unity Technologies, 2024). In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In my game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why I have chosen the built-in Character Controller, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk up stairs and walk on slopes (Unity Technologies, 2024). The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. I used this for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so I implemented the gravity and jump mechanics seperately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, I used the following equations outlined by Kyle Pittman (2016):
\begin{equation}
\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
\end{equation}

\begin{equation}
\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
\end{equation}
\paragraph{}
% Code Snippet (below)
\begin{verbatim}
private void SetupJumpVariables()
{
    float timeToApex = _maxJumpTime / 2;
    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
}
\end{verbatim}
For the gravity applied to the player while grounded, I used a smaller value of gravity to avoid unecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

\section{Enemy AI \& Combat}
Still to include : \newline
- Strategy pattern for enemies \newline

- Observer for combat system + UML \newline
- NavMesh agents for AI pathfinding for enemies \newline
- Coroutines  \newline
\section{User Experience}
Still to include: \newline
- Player input \newline
- Cinemachine for smooth camera movement \newline
- Animation \newline
- UI \newline
- Input system : Controller and keyboard controls \newline

%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}

\section{Development Diary}
\textbf{Week 10}\newline
25/11/2024
\newline- Created the HUD (Heads up diplay) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters it's follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured it's movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage
\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name}
\end{figure}
The Assets folder contains all of the work I have completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram hilights the most important subfolders, such as the scripts folders, where all my C\# scripts are organised. Note that not all folders are included in the diagram.
\section{Demo Video Link}

%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliography}
\subsection{Cited References}
\item Unity Technologies. (2022) \textit{Level up your code with game programming patterns}. Available at: https://unity.com/resources/level-up-your-code-with-game-programming-patterns (Accessed: 10 October 2024)
\item Unity Technologies. (2024) \textit{CharacterController}. Available at: https://docs.unity3d.com/6000.0/Documentation/ScriptReference/CharacterController.html (Accessed: 10 November 2024)
\item Unity Technologies. (2024) \textit{CharacterController component reference}. Available at: https://docs.unity3d.com/6000.0/Documentation/Manual/class-CharacterController.html (Accessed: 10 November 2024)
\item Kyle Pittman (2016): \textit{Math for Game Programmers: Building a Better Jump}, [YouTube] https://www.youtube.com/watch?v=hG9SzQxaCm8\&t=1383s.
\subsection{Further Research and Tutorials}
\subsection{Assets Used}
\end{thebibliography}
\label{endpage}

\end{document}

\end{article}
