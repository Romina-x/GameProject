\documentclass[]{final_report}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{xcolor} % Added package for text coloring
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{forest}
\usepackage{cite}
\usepackage{float}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 

\vskip3em

Signature:

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
- 100-200 words \newline
- What does this report cover? \newline

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Objectives

\chapter{Objectives}
- Objectives you agreed on from the specification of the project
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
- Context \& motivation \newline
- Game concept description \& mechanics \newline
- Brief description of what is in the report \newline


%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
\section{Game Engines}
For the development of this game, I have chosen to use Unity game engine. `Game engines are platforms that make it easier to create computer games. They allow you to integrate and combine into single unit individual game elements such as animations, interaction with the user, or detection of collisions between objects' \cite{Barczak2019}. There are many game engines available for 3D development, with notable examples including Unity, Unreal Engine, and CryEngine. These engines provide reusable components, allowing developers to focus on gameplay and design rather than redeveloping fundamental systems \cite{Barczak2019}. Unity stands out as the best choice for my project due to its powerful capabilities, user-friendly interface, and well documented resources. Unreal Engine 4 and Unity are the two most developed engines, with Unreal Engine being more suited to experienced users providing remarkable graphics, while Unity is more suited to beginners with a large asset library and simpler user interface. \cite{Christopoulou2017}.
\newline - add about how unity uses c\# and it enables OOP and stuff
\section{Design Patterns}
As programs get larger, it is critical to write code in such a way that classes and modules can communicate with each other in an intelligent way \cite{alma997871033502671}. In the context of game development, the complexity of the code can become large very fast, making it important to ensure that the code is clean, reusable, and scalable. Design patterns provide solutions to common design problems, enabling code to be easily extended and reused. There are many patterns that are widely used across many types of games. Some specific patterns I have chosen to use for the game are the Hierarchical State Machine, Observer pattern, Strategy pattern and the Component Object Model. 
\subsection{Hierarchical State Machine}\label{HSM}
The Hierarchical State Machine (HSM)  is a variation of the standard Finite State Machine (FSM) design pattern. The FSM pattern addresses player/object states for example, walking, idle and running and encapsulates each as an object. This pattern solves two problems: an object should change itâ€™s behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states \cite{unity2022_patterns}. I will use this for the player's movement, as the player is the most complex game object in terms of states. Using a state machine simplifies the process of adding new states without affecting existing ones.  It ensures all states are handled consistently, avoiding conflicts. A HSM builds on the concept of FSM by adding a hierarchy of states, allowing shared behaviours across multiple states. This includes super states and sub states, which can run simultaneously. Super states manage the shared behaviour across the substates, while the substates define specific actions.
\subsection{Observer}\label{observer}
The Observer Pattern is particularly useful in games when an event occurs and multiple objects need to be notified to perform specific actions. Without this pattern, the subject would need to reference each observer directly, resulting in high coupling between classes. The pattern involves observer and subject classes, where the observer contains a method that defines what action to take when notified by the subject, while the subject keeps a list of observers and notifies them when a specific event occurs \cite{nystrom2011game}. This decouples the objects, allowing the subject to notify multiple observers without explicitly referencing them. I have decided to use this pattern in a few places in the game's code. for example, the event of a health change in the player or enemy notifying related elements such as health bars or the game over screen.
\newline
- Description \& explanation of all the concepts you used so far with citations. Best to put it into sections like '1.1' so you can reference them later on \newline
- Game engine choice  \newline
- What is involved in making a game  \newline
- Strategy and COM still to go for DP \newline
 
%%%%%%%%%%%%%%%%%%%%%%
%%% Planning & Timeline
\chapter{Planning \& Timeline}
- Re write timeline from the project plan and indicate any changes from the original plan\newline
The project timeline is divided into two terms. Term 1 focuses on developing and refining the core game mechanics, while Term 2 is dedicated to expanding features and optimising performance.

\subsection{Term 1}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1: & \textcolor{black}{|} & $\bullet$ & Learning and understanding the fundamentals of Unity game engine \\
Week 2: & \textcolor{black}{|} & $\bullet$ & Finalise the core game concept and gather all assets \\
Week 3-4: & \textcolor{black}{|} & $\bullet$ & Prototyping: Animations and movement for player and enemies\\
Week 5-6: & \textcolor{black}{|} & $\bullet$ &  Prototyping: Enemy interactions and health mechanics \\
& \textcolor{black}{|} & $\bullet$ & \textbf{Initial player and enemy movement prototype working by Week 7} \\
Week 7-8: & \textcolor{black}{|} & $\bullet$ & Design and User Interface: First level design and creating base user interface screens\\
Week 9: & \textcolor{black}{|} & $\bullet$ & Initial play-testing: Bug fixing and gathering feedback from users to refine core gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Level one finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on interim report and presentation \\
\end{tabular}

\subsection{Term 2}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1-3: & \textcolor{black}{|} & $\bullet$ & Feature Expansion: Multiple levels, score system, weapon upgrades\\
Week 4-5: & \textcolor{black}{|} & $\bullet$ & Audio and sound effects implementation \\
Week 6-7: & \textcolor{black}{|} & $\bullet$ &  Improvements to current graphics and game optimisation \\
Week 8: & \textcolor{black}{|} & $\bullet$ & Improving and expanding on current mechanics \\
Week 9-10: & \textcolor{black}{|} & $\bullet$ & Final play-testing : Bug fixing and gathering feedback from users to refine style and gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Final game with expanded features finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on final report \\
\end{tabular}
%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
 - Possibly info about unity engine \& why I chose it
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in section \ref{HSM}.  I decided specifically to use a HSM for the player's movement as there was shared behaviour that I wanted to apply across multiple states without duplicating it into each one.  For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure \ref{fig:label_State} details this architecture:
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_State}
\end{figure}
\newline The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and it's Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. I chose here to use the factory pattern for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}
In my game, I chose to use Unity's built in Character Controller for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics \cite{unity2024_charactercontroller}. In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In my game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why I have chosen the built-in Character Controller, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk up stairs and walk on slopes \cite{unity2024_charactercontroller_reference}. The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. I used this for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so I implemented the gravity and jump mechanics seperately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, I used the following equations outlined by Kyle Pittman \cite{pittman2016_jump}:
\begin{equation}
\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
\end{equation}

\begin{equation}
\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
\end{equation}
\paragraph{}
% Code Snippet (below)
\begin{verbatim}
private void SetupJumpVariables()
{
    float timeToApex = _maxJumpTime / 2;
    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
}
\end{verbatim}
For the gravity applied to the player while grounded, I used a smaller value of gravity to avoid unecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

\section{Enemy Movement and AI}
- Strategy pattern for enemies \newline
\subsection{Enemy Movement}
- 
\subsection{Combat System}
The combat system is a core feature of the game, enabling attack and damage mechanics between the player and enemies. The design focusses on handling the damage mechanic in a consistent way across both enemies and player, while accomodating their differing attack mechanics. This was achieved by creating an IDamageable interface, which must be implemented by all game objects capable of taking damage. This design is detailed in figure  \ref{fig:label_combat}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/CombatUML.drawio.png}
    \caption{UML Class digram of Combat System}
    \label{fig:label_combat}
\end{figure}
The IDamageable interface is the core of the system, which defines a TakeDamage() method which reduces the entity's health based on an incoming damage value. Both the Enemy and PlayerHealthAndDamage classes implement this interface, ensuring damage is applied in a consistent way for both entities. 
\newline The player's combat mechanic is controlled by the WeaponAttributes class. The weapon is equipped with a box collider that calls the OnTriggerEnter() method on collision. Within OnTriggerEnter(), the TakeDamage() method is called on the enemy that entered the collider. The WeaponManager class manages the weapon's box collider, ensuring that it is only enabled during the player's attack animation. This is achieved with Unity animation events, which call the EnableWeaponCollider() method at the appropriate time during the attack animation.
\newline The enemy's combat system differs from the player's, as it does not rely on weapon collision mechanics. Instead, the AttackRadius class manages the enemy's attack behaviour. This system uses a sphere collider that defines a radius in which the player can take damage. When the player is within this radius, the enemy periodically attacks by calling the player's TakeDamage() method. The  attacks are based on a set delay, allowing different enemy types to vary in attack speed.

\ref{observer}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/HealthObserverUML.drawio.png}
    \caption{UML Class digram of Health Observer Pattern}
    \label{fig:label_observer1}
\end{figure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/DefeatObserverUML.drawio.png}
    \caption{UML Class digram of Enemy Defeat Observer Pattern.}
    \label{fig:label_observer2}
\end{figure}
Still to include : \newline
- Observer for combat system + UML \newline
- NavMesh agents for AI pathfinding for enemies \newline
- Coroutines  \newline
\section{User Experience}
Still to include: \newline
- Cinemachine for smooth camera movement \newline
- Animation \newline
- UI \newline
- Input system : Controller and keyboard controls \newline
- Level Design

%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}

\section{Development Diary}
\textbf{Week 10}\newline
25/11/2024
\newline- Created the HUD (Heads up diplay) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters it's follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured it's movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage
\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{OtherImages/FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name2}
\end{figure}
The Assets folder contains all of the work I have completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram hilights the most important subfolders, such as the scripts folders, where all my C\# scripts are organised. Note that not all folders are included in the diagram.
\section{Demo Video Link}
- Maybe also add a code style thing.
%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\bibliographystyle{plain}
\bibliography{references}
\section{Cited References}
\section{Further Research and Tutorials}
\section{Assets Used}
\label{endpage}

\end{document}

\end{article}
