\documentclass[]{final_report}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{array}
\usepackage{xcolor} % Added package for text coloring
\usepackage{titlesec}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{forest}
\usepackage{cite}
\usepackage{float}


%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{Romina Petrozzi}
\def\reportyear{2024}
\def\projecttitle{Building a Game}
\def\supervisorname{Julien Lange}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

\chapter*{Declaration}

This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

\vskip3em

Word Count: 

\vskip3em

Student Name: \studentname

\vskip3em

Date of Submission: 

\vskip3em

Signature:

\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
- 100-200 words \newline
- What does this report cover? \newline

\end{abstract}
\newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Objectives

\chapter{Objectives}
- Objectives you agreed on from the specification of the project
%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}
- Context \& motivation \newline
- Game concept description \& mechanics \newline
- Brief description of what is in the report \newline


%%%%%%%%%%%%%%%%%%%%%%
%%% Background
\chapter{Background}
Game development is a multidisciplinary process that includes areas such as creating a game concept, designing its mechanics, and creating an engaging user interface and experience. Each of these elements are equally important to create a game that is accessible, enjoyable, and polished. This section talks about some key areas of the development process that I have focused on so far, including selecting an appropriate game engine, designing code that is reusable and expandable, and developing the user interface and experience.
\section{Game Engines}
For the development of this game, I have chosen to use Unity game engine. `Game engines are platforms that make it easier to create computer games. They allow you to integrate and combine into single unit individual game elements such as animations, interaction with the user, or detection of collisions between objects' \cite{Barczak2019}. There are many game engines available for 3D development, with notable examples including Unity, Unreal Engine, and CryEngine. These engines provide reusable components, allowing developers to focus on gameplay and design rather than redeveloping fundamental systems \cite{Barczak2019}. Unity stands out as the best choice for my project due to its powerful capabilities, user-friendly interface, and well documented resources. Unreal Engine 4 and Unity are the two most developed engines, with Unreal Engine being more suited to experienced users providing remarkable graphics, while Unity is more suited to beginners with a large asset library and simpler user interface \cite{Christopoulou2017}.
\section{Design Patterns}
As programs get larger, it is critical to write code in such a way that classes and modules can communicate with each other in an intelligent way \cite{alma997871033502671}. In the context of game development, the complexity of the code can become large very fast, making it important to ensure that the code is clean, reusable, and scalable. Design patterns provide solutions to common design problems, enabling code to be easily extended and reused. There are many patterns that are widely used across many types of games. Some specific patterns I have chosen to use for the game are the Hierarchical State Machine, Observer pattern, Strategy pattern and the Component Object Model. 
\subsection{Hierarchical State Machine}\label{HSM}
The Hierarchical State Machine (HSM)  is a variation of the standard Finite State Machine (FSM) design pattern. The FSM pattern addresses player/object states for example, walking, idle and running and encapsulates each as an object. This pattern solves two problems: an object should change itâ€™s behaviour when its internal state changes, and adding new states does not impact the behaviour of existing states \cite{unity2022_patterns}. I will use this for the player's movement, as the player is the most complex game object in terms of states. Using a state machine simplifies the process of adding new states without affecting existing ones.  It ensures all states are handled consistently, avoiding conflicts. A HSM builds on the concept of FSM by adding a hierarchy of states, allowing shared behaviours across multiple states. This includes super states and sub states, which can run simultaneously. Super states manage the shared behaviour across the substates, while the substates define specific actions.
\subsection{Observer}\label{observer}
The Observer Pattern is particularly useful in games when an event occurs and multiple objects need to be notified to perform specific actions. Without this pattern, the subject would need to reference each observer directly, resulting in high coupling between classes. The pattern involves observer and subject classes, where the observer contains a method that defines what action to take when notified by the subject, while the subject keeps a list of observers and notifies them when a specific event occurs \cite{nystrom2011game}. This decouples the objects, allowing the subject to notify multiple observers without explicitly referencing them. I have decided to use this pattern in a few places in the game's code. for example, the event of a health change in the player or enemy notifying related elements such as health bars or the game over screen.
\subsection{Strategy}\label{strategy}
The Strategy pattern is a design pattern used to define a family of behaviours and make them interchangeable. This pattern is commonly used in game development to handle different enemy behaviours or player mechanics. The pattern involves enapsulating a set of behaviours and having the client control the behaviour through an interface, instead of hardcoding the behaviour into the client function itself \cite{Doran2017}. This approach allows new behaviors for game objects to be added easily without duplicating the original class, as the class can dynamically swap between different behaviors. I have chosen to use this pattern in my game for creating multiple enemy types.
\newline
- Strategy and COM still to go for DP \newline
\section{User Experience}
Creating an engaging and intuitive user interface (UI) and user experience (UX) is important in modern game development. 
UX in games includes the player's overall interaction with the game, including controls, interface design, camera systems, feedback mechanisms, and navigation flows \cite{Kramarzewski2023}. It focuses on ensuring that the game is enjoyable, accessible, and meets player expectations. 
\newline Designing effective input involves adhering to the principles of ergonomics and user expectations. Ergonomics refers to creating controls that are natural for hand movement, while user expectations involve using input controls that are familiar, so players can quickly learn the controls \cite{Rogers2014}. For example, the WASD keys are commonly used for movement in PC games because they are familiar to most players, and they allow a natural position for the hand on the keyboard. Camera systems are essential in games to determine the player's perspective of the game world. Common types include first-person, third-person and top-down cameras, each providing different approaches to the gameplay design \cite{Kramarzewski2023}. 
\section{User Interface and Level Design}\label{UIandLevel}
%%%%%%%%%%%%%%%%%%%%%%
%%% Planning & Timeline
\chapter{Planning \& Timeline}
- Re write timeline from the project plan and indicate any changes from the original plan\newline
The project timeline is divided into two terms. Term 1 focuses on developing and refining the core game mechanics, while Term 2 is dedicated to expanding features and optimising performance.

\subsection{Term 1}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1: & \textcolor{black}{|} & $\bullet$ & Learning and understanding the fundamentals of Unity game engine \\
Week 2: & \textcolor{black}{|} & $\bullet$ & Finalise the core game concept and gather all assets \\
Week 3-4: & \textcolor{black}{|} & $\bullet$ & Prototyping: Animations and movement for player and enemies\\
Week 5-6: & \textcolor{black}{|} & $\bullet$ &  Prototyping: Enemy interactions and health mechanics \\
& \textcolor{black}{|} & $\bullet$ & \textbf{Initial player and enemy movement prototype working by Week 7} \\
Week 7-8: & \textcolor{black}{|} & $\bullet$ & Design and User Interface: First level design and creating base user interface screens\\
Week 9: & \textcolor{black}{|} & $\bullet$ & Initial play-testing: Bug fixing and gathering feedback from users to refine core gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Level one finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on interim report and presentation \\
\end{tabular}

\subsection{Term 2}
\begin{tabular}{@{}p{2cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}>{\raggedright\arraybackslash}p{0.5cm}@{}p{12cm}}
Week 1-3: & \textcolor{black}{|} & $\bullet$ & Feature Expansion: Multiple levels, score system, weapon upgrades\\
Week 4-5: & \textcolor{black}{|} & $\bullet$ & Audio and sound effects implementation \\
Week 6-7: & \textcolor{black}{|} & $\bullet$ &  Improvements to current graphics and game optimisation \\
Week 8: & \textcolor{black}{|} & $\bullet$ & Improving and expanding on current mechanics \\
Week 9-10: & \textcolor{black}{|} & $\bullet$ & Final play-testing : Bug fixing and gathering feedback from users to refine style and gameplay\\
& \textcolor{black}{|} & $\bullet$ & \textbf{Final game with expanded features finished by Week 10} \\
Week 10-11: & \textcolor{black}{|} & $\bullet$ & Work on final report \\
\end{tabular}
%%%%%%%%%%%%%%%%%%%%%%
%%% Development
\chapter{Development}
\section{Player Movement}
Creating smooth and responsive movement for the player is essential for the user experience, as 3D platformer games require precise movements to traverse the levels. The player's movement covers standing idle, walking, running and jumping. 
\subsection{Architecture}
The architecture for the player's movement uses a Hierarchical State Machine (HSM) , as discussed in section \ref{HSM}.  I decided specifically to use a HSM for the player's movement as there was shared behaviour that I wanted to apply across multiple states without duplicating it into each one.  For example, there is a Grounded super state that applies gravity to the Idle, Walk and Run substates. Figure \ref{fig:label_State} details this architecture:
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/PlayerStateUML.drawio.png}
    \caption{UML Class digram of Player State Machine.}
    \label{fig:label_State}
\end{figure}
\newline The PlayerStateMachine is the core component which manages the players states and transitions. This script is attached to the player game object and it's Update() method is called every frame to handle the player movement and state changes. PlayerStateFactory handles the creation of states for the StateMachine, which uses them for the transitions between player behaviours. I chose here to use the factory pattern for state creation as it simplifies the management of numerous states, making the StateMachine more readable. It also decouples the states from the StateMachine, allowing the architecture to be more easily reused with other state factories. PlayerBaseState is an abstract class that defines the common methods and behaviours for each state.  It provides access to the current StateMachine and StateFactory while also defining the core methods (EnterState(), UpdateState() and ExitState()) that the states need to implement for proper transitions. The state classes (Idle, Walk, Run, Jump and Grounded) are concrete implementations of PlayerBaseState. Each state contains the unique logic specific to its intended behaviour. For example, the Jump state handles the physics for the upward force and gravity during the jump. In addition, each state defines the conditions in which to transition to a neighbouring state. As mentioned previously, the states are organised in a hierarchy. Grounded and Jump are superstates while Idle, Walk and Run are substates. 
\subsection{Movement Physics}
In my game, I chose to use Unity's built in Character Controller for player movement rather than implementing Rigidbody based movement. The built in character controller allows you to easily implement basic movement (Walking) with collisions, but the player will not be affected by physics \cite{unity2024_charactercontroller}. In contrast, Rigidbodies put the game object under the effect of Unity's physics engine, and gravity is automatically applied and the object will react to impact from other Rigidbodies. In my game, the player needs to move around and jump across platforms, and the combat mechanics are physical. Therefore, the game requires limited use of physics beyond gravity.  This is why I have chosen the built-in Character Controller, as it avoids complex physics calculations and interactions that are not necessary. \newline
The Character Controller component is a capsule-shaped collider that can be told to move in some direction from a script. It will stop at walls, walk up stairs and walk on slopes \cite{unity2024_charactercontroller_reference}. The controller uses the Move() method to apply movement to the player by taking a movement vector and adjusting the player's position. I used this for the player's walking and running states, incorporating a run multiplier to differentiate between walking and running speeds. However, the Character Controller does not cover all movement aspects, so I implemented the gravity and jump mechanics seperately.  \newline
The jump trajectory is calculated by applying an initial upward velocity and adjusting it with gravity over time. The initial velocity is calculated based on the desired maximum jump height and the time it takes to reach the apex of the jump. This ensured that the player reaches the jump height within the given time. Once the initial velocity is applied, gravity is applied continuously which decelerates the player until the apex, then accelerates them back to the ground. To calculate the initial velocity and gravity required for a parabolic jump motion, I used the following equations outlined by Kyle Pittman \cite{pittman2016_jump}:
\begin{equation}
\text{Gravity} = \frac{-2 \cdot \text{MaxJumpHeight}}{(\text{TimeToApex})^2}
\end{equation}

\begin{equation}
\text{Initial Jump Velocity} = \frac{2 \cdot \text{MaxJumpHeight}}{\text{TimeToApex}}
\end{equation}
\paragraph{}
\begin{verbatim}
private void SetupJumpVariables()
{
    float timeToApex = _maxJumpTime / 2;
    _gravity = (-2 * _maxJumpHeight) / Mathf.Pow(timeToApex, 2);
    _initialJumpVelocity = (2 * _maxJumpHeight) / timeToApex;
}
\end{verbatim}
For the gravity applied to the player while grounded, I used a smaller value of gravity to avoid unecessary gravitational calculations and to prevent the high gravity from slowing down the player's movement. \newline

%%%%%%%%%%%%%%%%%%%%%%
%%% Enemies and Combat#
\section{Enemy Movement}
The enemy movement in the game is implemented dynamically based on the player's proximity. The enemies start in an idle state and begin to chase the player when they come within a specified range. Once the player moves out of this range, the enemies return back to their original starting position. To implement this behaviour with intelligent navigation I chose to use Unity's AI module, which supports AI pathfinding using NavMesh Surfaces and NavMeshAgents \cite{unity2024_AI}. 
A NavMeshAgent is assigned to each enemy, allowing them to navigate across a NavMeshSurface while avoiding obstacles in their path. These agents are configured with properties such as movement speed, acceleration, avoidance priority, and movement radius, which control thier movement behaviour \cite{unity2024_NavAgent}. The NavMeshSurface is assigned to the level's entire terrain, defining the ground area that the enemies can move on. This approach allows enemies to intelligently avoid obstacles and dynamically chase the player while navigating complex environments. \newline
\subsection{Architecture}
Unlike the the player movement system, I chose not to implement the State Machine design pattern for the enemy movement states. The enemy states: Idle, Chasing and Returning are relatively simple, and using a State Machine would likely overcomplicate the system for such few states. However I may consider refactor the system if more complex enemy types are introduced later in develoopment, requiring additional states or behaviours. The current design is detailed in figure \ref{fig:label_enemyMovement}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyMovementUML.drawio}
    \caption{UML Class digram of Enemy Movement System.}
    \label{fig:label_enemyMovement}
\end{figure}
The FollowRadius component detcts when the player enters or exits the proximity radius. It makes use of a SphereCollider which calls OnTriggerEnter() and OnTriggerExit() when the player enters or exits the radius. It communicates this to EnemyMovement using events. 
\begin{verbatim}
private void OnTriggerEnter(Collider other) 
{
    IDamageable damageable = other.GetComponent<IDamageable>();
    if (damageable != null)
    {
        PlayerEnter?.Invoke();
    }
}
\end{verbatim}
EnemyMovement subscribes to the PlayerEnter and PlayerExit events from FollowRadius and begins manages the enemy's movement coroutines based on the event. A coroutine is a method that allows you to spread tasks across several frames. It can pause execution and return control to Unity but then continue where it left off on the following frame \cite{unity2024_Coroutines}. I chose to make use of coroutines instead of the Update() method which runs every frame. This is because the enemy movement relies on constant checks for position updates such as the player's position to follow, and using a coroutine allows this behaviour to execute over time without repeatedly checking every frame. One of the coroutines from EnemyMovement is shown below:
\begin{verbatim}
private IEnumerator FollowTarget()
{
    WaitForSeconds wait = new WaitForSeconds(_updateSpeed);
    while(enabled){
        if (Target != null)
        {
            _isMoving = _agent.velocity.magnitude > 0.1f;
            _animator.SetBool(_isMovingHash, _isMoving);
            _agent.SetDestination(Target.position); 
        }
        yield return wait;
    }
}
\end{verbatim}
The Enemy class manages the overall behaviour and state of the enemies in the game. Concerning movement, it is responsible for configuring the properties of the NavMeshAgent (such as speed and stopping distance) but delegates the actual movement logic to the EnemyMovement class. This separation allows the Enemy class to keep its focus on managing overall enemy behaviours while delegating the more complex logic to other dedicated classes. For movement, it works with the EnemyMovement class, while for combat, it interacts with the AttackRadius class (Detailed in \ref{combatsystem}). 

\subsection{Configurable Enemies}
Currently in the game there are two enemy types, Goblin Warrior and Scout. Both are short range and vary in attack speed, health and moement speed. To enable multiple enemy types I used the Strategy pattern \ref{strategy} in conjunction with Unity's ScriptableObject feature. I chose to use Strategy here to enable the Enemy class to use dfferent behaviours interchangeably without hardcoding multiple Enemy classes for different enemy types. Unity's ScriptableObject is a data container that allows you to create customisable assets in the Unity editor \cite{unity2024_ScriptableObject}. I used this along with the Strategy pattern methodology to create seperate configurable data containers for the two different enemy types. This design is detailed in figure \ref{fig:label_strategy}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/EnemyStrategyUML.drawio}
    \caption{UML Class digram of Enemy Strategy Pattern.}
    \label{fig:label_strategy}
\end{figure}
The EnemyScriptableObject stores all the customizable parameters, such as health, attack speed, and movement speed. The Enemy class uses the data from the assigned ScriptableObject (GoblinWarrior or GoblinScout) to adjust its behavior dynamically. This approach decouples the enemy configuration from the core enemy logic, allowing new enemy types to be added easily by creating new ScriptableObjects without modifying the Enemy class. 
\section{Combat System}\label{combatsystem}
The combat system is a core feature of the game, enabling attack and damage mechanics between the player and enemies. The design focusses on handling the damage mechanic in a consistent way across both enemies and player, while accomodating their differing attack mechanics. This was achieved by creating an IDamageable interface, which must be implemented by all game objects capable of taking damage. This design is detailed in figure  \ref{fig:label_combat}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/CombatUML.drawio.png}
    \caption{UML Class digram of Combat System}
    \label{fig:label_combat}
\end{figure}
The IDamageable interface is the core of the system, which defines a TakeDamage() method which reduces the entity's health based on an incoming damage value. Both the Enemy and PlayerHealthAndDamage classes implement this interface, ensuring damage is applied in a consistent way for both entities. 
\newline The player's combat mechanic is controlled by the WeaponAttributes class. The weapon is equipped with a Box Collider that calls the OnTriggerEnter() method on collision. Within OnTriggerEnter(), the TakeDamage() method is called on the enemy that entered the collider. The WeaponManager class manages the weapon's Box Collider, ensuring that it is only enabled during the player's attack animation. This is achieved with Unity animation events, which call the EnableWeaponCollider() method at the appropriate time during the attack animation.
\newline The enemy's combat system differs from the player's, as it does not rely on weapon collision mechanics. Instead, the AttackRadius class manages the enemy's attack behaviour. This system uses a Sphere Collider that defines a radius in which the player can take damage. When the player is within this radius, the enemy periodically attacks by calling the player's TakeDamage() method. The  attacks are based on a set delay, allowing different enemy types to vary in attack speed.


\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/DefeatObserverUML.drawio.png}
    \caption{UML Class digram of Enemy Defeat Observer Pattern.}
    \label{fig:label_observer2}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%
%%% User Experience#
\section{User Interface}
So far in my game I have implemented a basic UI including a Game Over screen, and a HUD \ref{UIandLevel}, which displayes health bars for both the player and enemies. To design the UI components, I used Unity's built-in UI package \cite{unity2024_UI} to create multiple canvases to display various types of information to the user. For communication between the UI elements and relevant game objects, I used the Observer pattern, as discussed in section \ref{observer}. I chose to use this pattern in this context to decouple the UI components from the game logic. This allows the game objects to act as subjects, and notify the relevant UI components (observers) without needing to hold direct references to them. Currently, there are two subjects (the enemy and player), and three observers (the enemy and player's health bars and the game over screen). This design is shown in figure \ref{fig:label_observer1}.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{UMLDiagrams/HealthObserverUML.drawio.png}
    \caption{UML Class digram of Health Observer Pattern}
    \label{fig:label_observer1}
\end{figure}
I have implemented two interfaces to manage health changes: one for the subject and one for the observers. The IHealthSubject interface defines methods for registering, unregisternig and notifying observers about health changes. The IHealthObserver interface specifies an OnNotify() method, that passes the observer the updated health value and defines what it should do given the new value. 
The PlayerHealthAndDamage and Enemy classes implement the IHealthSubject interface. Each holds a list of observers that are managed with the register and unregister observer methods. When a health change happens, the subjects notify their observers by calling the OnNotify() method for each observer in the list.  
\begin{verbatim}
public void NotifyHealthObservers()
{
    foreach (IHealthObserver observer in _observers)
    {
        observer.OnNotify(_maxHealth, _health);
    }
}
\end{verbatim}
The PlayerHealthBar, EnemyHealthBar and GameOver classes implement the IHealthObserver interface. The Game Over screen needs to observe the player's health and subsequently pop up if their health is below zero. 
The health bars observe the player and enemies to display their current health in real time. Each observer registers itself with its associated subject by calling the subject's RegisterHealthObserver(this) method. Once registered, the subject calls the observer's OnNotify() method whenever there is a health update. For example, when an Enemy notifies the EnemyHealthBar, the following method is called:
\begin{verbatim}
public void OnNotify(float maxHealth, float currentHealth)
{
    UpdateHealthBar(maxHealth, currentHealth);
}
\end{verbatim}
While the use of this pattern may seem overcomplex for this scenario, as there are very few observers, I have set it up with future development in mind. As more UI components, sound effects, and visual effects are added, these elements will need to observe the same properties. Without the observer pattern, the game objects would need to hold numerous references to these components, making the system tightly coupled and complex. 


\section{User Experience}
- Cinemachine for smooth camera movement \newline
- Input system : Controller and keyboard controls \newline
- Level Design

%%%%%%%%%%%%%%%%%%%%%%
%%% Appendix#
\appendix
\chapter{Appendix}

\section{Development Diary}
\textbf{Week 10}\newline
25/11/2024
\newline- Created the HUD (Heads up diplay) for the player which includes player and enemy health bars.
\newline- Created game over screen with restart level button, which is triggered when the player's health is below zero.
 
\textbf{Week 9}\newline
20/11/2024
\newline- Reconfigured NavMeshSurface to fit the new terrain so that enemies can move around the new level area.
\newline- Refactored code style on all files to follow unity guidelines for readability.
\newline19/11/2024
\newline- Continued building level one terrain.

\textbf{Week 8}\newline
16/11/2024
\newline- Began constructing level one terrain and features.
\newline11/11/2024
\newline- Added cage with trapped animal for rescue mechanic: Enemies guard a cage and when they are defeated the cage disappears and the animal is released.

\textbf{Week 7}\newline
10/11/2024
\newline- Extra bug fixing for player movement:
\newline- Fix to jump animation bug which caused it to look like a double jump.
\newline- Fix to bug that caused animations to get stuck when pressing jump twice.
\newline9/11/2024
\newline- Added a movement radius to the enemy: Now the enemy only starts following the player if the player enters its follow radius. The Enemy returns to spawn if player exits the radius.
\newline6/11/2024
\newline- Aded player attack mechanic: Enemy takes damage on collision with the player's axe.
\newline- Situation where player dies is still unhandled.
\newline5/11/2024
\newline- Added death animation for player.
\newline- Fixed bug where enemy continues to follow player when dead.
\newline4/11/2024
\newline- Implemented enemy attack mechanic: Enemy auto attacks when the player is in range (Within the attack radius).

\textbf{Week 6}\newline
29/10/2024
\newline- Refactored all the states out into their respective classes.
\newline- Fixed gravity and running bugs from refactored code.

\textbf{Week 5}\newline
25/20/2024
\newline- Began refactoring player class into a hierarchical state machine.
\newline- Created all state classes and state factory.
\newline23/10/2024
\newline- Linked running animation to enemy movement.
\newline21/10/2024
\newline- Imported enemy prefab and configured its movement to follow the player.
\newline- Researched Nav Meshes and applied this to the enemy so that it uses AI to navigate around obstacles towards the player.

\textbf{Week 4}\newline
16/10/2024
\newline- Fixed the jump movement and added the jump animation to it.
\newline15/10/2024
\newline- Researched animation layering for attack movement.
\newline- Added attack animation that layers over walking and running.

\textbf{Week 3}\newline
13/10/2024
\newline- First attempt at jump physics / movement. Not fixed.
\newline- Added basic terrain / skybox.
\newline12/10/2024
\newline- Added walk and run movement, and linked them to their corresponding animations.
\newline08/10/2024
\newline- Began prototyping player character.
\newline- Tied idle, walking and running animations to the keyboard keys.

\textbf{Week 2}\newline
05/10/2024
\newline- Finished gathering 3D assets.
\newline- Researched player movement in unity.
\newline03/10/2024
\newline- Finalised game idea and mechanics and documented them.
\newline- Began gathering 3D assets.

\newpage
\section{Submission Directory Structure}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{OtherImages/FileStructure.png}
    \caption{Diagram of Directory Structure}
    \label{fig:label_name2}
\end{figure}
The Assets folder contains all of the work I have completed so far including the 3D models for the player, enemies, terrain etc., as well as the associated scripts and animations. The diagram hilights the most important subfolders, such as the scripts folders, where all my C\# scripts are organised. Note that not all folders are included in the diagram.
\section{Demo Video Link}
- Maybe also add a code style thing.
%%%% ADD YOUR BIBLIOGRAPHY HERE
\newpage
\bibliographystyle{plain}
\bibliography{references}
\section{Cited References}
\section{Further Research and Tutorials}
\section{Assets Used}
\label{endpage}

\end{document}

\end{article}
